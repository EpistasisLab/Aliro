/* ~This file is part of the PennAI library~

Copyright (C) 2017 Epistasis Lab, University of Pennsylvania

PennAI is maintained by:
    - Heather Williams (hwilli@upenn.edu)
    - Weixuan Fu (weixuanf@upenn.edu)
    - William La Cava (lacava@upenn.edu)
    - Michael Stauffer (stauffer@upenn.edu)
    - and many other generous open source contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

(Autogenerated header, do not modify)

*/
import FileUpload from './';
//import SceneHeader from '../SceneHeader';
// try getting react pieces and framework for test rendering
import React from 'react';
import renderer from 'react-test-renderer';
import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import fetch from 'jest-fetch-mock';
import fetchMock from 'fetch-mock';
import Dropzone from 'react-dropzone'

const middlewares = [thunk];
const initialState = {};
const mockStore = configureStore(middlewares);

import { shallow, mount, render, configure } from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';
configure({ adapter: new Adapter() });


//// NOTE on getting state
//
// The enzyme wrapper method 'state' (and related methods) is not working on mount(<my component>).
// I think it's because the component is wrapped with redux connect().
// So you can use shallow(<my component>).dive().state(),
//  or more direclty shallow(<my component>).dive().instance().state
// I don't know which is better.
//
describe('basic testing of fileupload react component', () => {
  let store = mockStore(initialState);
  let fullDom;
  let instance;
  let fakeFile = {target: {files: [{name: 'iris.csv'}]}};
  let fakeFileTsv = {target: {files: [{name: 'iris.tsv'}]}};
  let badFakeFile = {target: {files: [{name: 'iris.txt'}]}};
  // basic bookkeeping before/after each test; mount/unmount component, should be
  // similar to how piece will actually work in browser
  beforeEach(() => {
    fullDom = mount(<FileUpload store={store} testProp='hello' />);
    instance = shallow(<FileUpload store={store}/>).dive().instance();
  })
  afterEach(() => {
    fullDom.unmount();
  })

  //test that the componement instance is viable
  it('test instance', () => {
    //NOTE with react-redux, need 'dive()' to get the 'true' (not sure of the term) component instance.
    expect(instance).not.toEqual(null);
    //Test calling a method on the instance
    expect(instance.instanceTest()).toEqual('foobar');
    //Test retrieving state from the instance. See note above about accessing state.
    expect(instance.state.testStateValue).toEqual('foobar');
  })

  // test for existence
  //NOTE 'it' is an alias for 'test'
  it('create mock fileupload component, test for existence', () => {
    //console.log('jest console log!'); //this works, outputs to console at test script runtime
    fullDom.setProps({ name: 'bar' });
    expect(fullDom.name()).toEqual('Connect(FileUpload)');
    expect(fullDom.props().testProp).toEqual('hello');
    expect(fullDom.props().name).toEqual('bar');
  })

  //snapshot of component
  //I believe shallow is better since it won't include child components
  it('full component snapshot', () => {
    expect(shallow(<FileUpload store={store}/>).dive()).toMatchSnapshot();
  })

  it('simple change to component state', () => {
    expect(fullDom.props().name).toBeUndefined();
    expect(fullDom.state('dependentCol')).toBeUndefined();
    fullDom.setState({dependentCol: 'class'})
    expect(fullDom.state('dependentCol')).toEqual('class');
  })

  it('TODO - simulate user entering data with file upload form inputs', () => {
    expect(fullDom.find('FileUpload').length).toEqual(1);

    // asked about how to simulate user actions here, using enzyme simulate doesn't quite
    // work, using 'onChange' prop to fake user action:
    // https://stackoverflow.com/questions/55638365/how-to-access-internal-pieces-of-react-component-and-mock-api-call-with-jest-e/55641884#55641884

    // these actions are supposed to tigger event handlers in the component being
    // tested (which they do) & update component react state (which doesn't appear to happen)
    // this might be a limitation of enzyme

/*
    // this should create a browser console error - using javascript library to
    // create a file preview which attempts to parse given input, if input not a
    // file/blob the error is generated. The file onChange handler attempts to
    // create the file preview and set the selected file obj and file name in
    // the component's react state

    fullDom.find('input').at(0).prop('onChange')(fakeFile);

    // update() is supposed to forceUpdate/re-render the component
    fullDom.update();
    // manually updating, component react state does not contain anything, in any
    // case need to call update() to access elements by html dom ID


    // the following is a standin for user input entering metadata

    let depColTextField = fullDom.find('#dependent_column_text_field_input').at(0);
    // still need to access with 'at', using find('#dependent_column_text_field_input')
    // returns 4 nodes somehow
    depColTextField.prop('onChange')(
      {target:{value: 'test_class'}},
      {value:'test dep input'}
    );
    let ordTextArea = fullDom.find('#ordinal_features_text_area_input');
    ordTextArea.prop('onChange')(
      {target:{value: {testOrdKey: 'testHello'}}},
      {value:'test ord input'}
    );
    let catTextArea = fullDom.find('#categorical_features_text_area_input');
    catTextArea.prop('onChange')(
      {target:{value: 'testCatHello1, testCatHello2'}},
      {value:'test cat input'}
    );
    // cheating for now and just updating component state directly...
    fullDom.setState({
      selectedFile: fakeFile.target.files[0],
      ordinalFeatures: {testOrdKey: 'testHello'},
      catFeatures: 'testCatHello1, testCatHello2',
      dependentCol: 'test_class'
    });
    //console.log('test state: ', fullDom.state());
    //console.log('test file: ', fullDom.state('selectedFile'));
    // ...and checking for state which was just manually set above
    expect(fullDom.state('selectedFile')).toEqual(fakeFile.target.files[0]);
    expect(fullDom.state('ordinalFeatures')).toEqual({testOrdKey: 'testHello'});
    expect(fullDom.state('catFeatures')).toEqual('testCatHello1, testCatHello2');
    expect(fullDom.state('dependentCol')).toEqual('test_class');
  */
  })

  it('TODO - try uploading non csv/tsv file type', () => {
/*
    fullDom.find('input').at(0).prop('onChange')(badFakeFile);
    fullDom.update();
    //expect(fullDom.state('selectedFile')).toEqual(badFakeFile.target.files[0]);
    expect(fullDom.state('selectedFile')).toBeUndefined();
    let formBody = fullDom.find('#file-upload-form-input-area');

    // check for CSS style which hides form
    expect(formBody.hasClass('file-upload-form-hide-inputs')).toEqual(true);
    expect(formBody.hasClass('file-upload-form-show-inputs')).toEqual(false);
*/
  })

  it('TODO - try testing generateFileData - good input', () => {
/*
    // use dive() to get at inner FileUpload class functions -
    // https://github.com/airbnb/enzyme/issues/208#issuecomment-292631244
    const shallowFileUpload = shallow(<FileUpload store={store}/>).dive();
    // all input from user will be read as strings
    const fakeUserInput = {
      depCol: 'target_class',
      catCols: 'a, b, c',
      ordFeats: '{"species": ["cat", "dog", "bird"]}'
    };
    // add fake file with filename so generateFileData will do something, if
    // no file & filename present generateFileData returns blank/empty formData
    shallowFileUpload.setState({
      selectedFile: fakeFile.target.files[0],
      dependentCol: fakeUserInput.depCol,
      catFeatures: fakeUserInput.catCols,
      ordinalFeatures: fakeUserInput.ordFeats
    });

    // expect list of comma separated cat cols to get parsed with string split
    // dependent columns will be stored as is (type string)
    // ordFeats will parse given JSON
    const expectedInput = {
      depCol: 'target_class',
      catCols: ['a', 'b', 'c'],
      ordFeats: {
        species: ["cat", "dog", "bird"]
      }
    };
    // use instance to get access to inner function
    const instance = shallowFileUpload.instance();
    // create spy, check function gets called
    const spy = jest.spyOn(instance, 'generateFileData');
    const testData = instance.generateFileData(); // FormData
    // get stuff stored in returned formdata, stingified in preparation to make
    // network request
    const metadata = JSON.parse(testData.get('_metadata'));
    expect(spy).toBeCalled();
    // value of _metadata defined in generateFileData
    expect(metadata.dependent_col).toEqual(expectedInput.depCol);
    expect(metadata.categorical_features).toEqual(expectedInput.catCols);
    expect(metadata.ordinal_features).toEqual(expectedInput.ordFeats);
*/
  })

  it('TODO - Select tsv file - expect form to be displayed', () => {
/*    
    fullDom.find('input').at(0).prop('onChange')(fakeFileTsv);

    // update() is supposed to forceUpdate/re-render the component
    fullDom.update();
    fullDom.setState({
      selectedFile: fakeFileTsv.target.files[0]
    });
    let formBody = fullDom.find('#file-upload-form-input-area');

    // check for CSS style which hides form
    expect(formBody.hasClass('file-upload-form-hide-inputs')).toEqual(false);
    expect(formBody.hasClass('file-upload-form-show-inputs')).toEqual(true);
    expect(fullDom.state('selectedFile')).toEqual(fakeFileTsv.target.files[0]);
*/
  })

  it('TODO - try testing generateFileData - bad input, no ordinal features', () => {
/*
    // use dive() to get at inner FileUpload class functions -
    // https://github.com/airbnb/enzyme/issues/208#issuecomment-292631244
    const shallowFileUpload = shallow(<FileUpload store={store}/>).dive();
    // all input from user will be read as strings
    const fakeUserInput = {
      depCol: 'target_c@#$@#$',
      catCols: 'a, b, c   , 4,,, ,',
      ordFeats: ''
    };
    // add fake file with filename so generateFileData will do something, if
    // no file & filename present generateFileData returns blank/empty formData
    shallowFileUpload.setState({
      selectedFile: fakeFileTsv.target.files[0],
      dependentCol: fakeUserInput.depCol,
      catFeatures: fakeUserInput.catCols,
      ordinalFeatures: fakeUserInput.ordFeats
    });

    // expect list of comma separated cat cols to get parsed with string split
    //  (remove whitespace and empty strings)
    // dependent columns will be stored as is (type string)
    // ordFeats will parse given JSON, if not proper JSON return empty obj
    const expectedInput = {
      depCol: 'target_c@#$@#$',
      catCols: ['a', 'b', 'c', '4'],
      ordFeats: ''
    };
    // use instance to get access to inner function
    const instance = shallowFileUpload.instance();
    // create spy, check function gets called
    const spy = jest.spyOn(instance, 'generateFileData');
    const testData = instance.generateFileData(); // FormData
    // get stuff stored in returned formdata, stingified in preparation to make
    // network request
    const metadata = JSON.parse(testData.get('_metadata'));
    expect(spy).toBeCalled();
    // value of _metadata defined in generateFileData
    expect(metadata.dependent_col).toEqual(expectedInput.depCol);
    expect(metadata.categorical_features).toEqual(expectedInput.catCols);
    expect(metadata.ordinal_features).toEqual(expectedInput.ordFeats);
*/
  })

  it('TODO - try testing generateFileData - bad input, with ordinal features', () => {
/*
    // use dive() to get at inner FileUpload class functions -
    // https://github.com/airbnb/enzyme/issues/208#issuecomment-292631244
    const shallowFileUpload = shallow(<FileUpload store={store}/>).dive();
    // all input from user will be read as strings
    const fakeUserInput = {
      depCol: 'target_c@#$@#$',
      catCols: 'a, b, c   , 4,,, ,',
      ordFeats: '{"species": ["cat", "dog", "bird"]}{"missing_comma": ["one","two"]}'
    };
    // add fake file with filename so generateFileData will do something, if
    // no file & filename present generateFileData returns blank/empty formData
    shallowFileUpload.setState({
      selectedFile: fakeFile.target.files[0],
      dependentCol: fakeUserInput.depCol,
      catFeatures: fakeUserInput.catCols,
      ordinalFeatures: fakeUserInput.ordFeats
    });

    // expect list of comma separated cat cols to get parsed with string split
    //  (remove whitespace and empty strings)
    // dependent columns will be stored as is (type string)
    // ordFeats will parse given JSON, if not proper JSON return empty obj
    const expectedInput = {
      depCol: 'target_c@#$@#$',
      catCols: ['a', 'b', 'c', '4'],
      ordFeats: ''
    };
    // use instance to get access to inner f
    const instance = shallowFileUpload.instance();
    // create spy, check function gets called
    const spy = jest.spyOn(instance, 'generateFileData');
    const testData = instance.generateFileData(); // FormData
    // returned content from generateFileData should be object containing error
    //console.log('error test: ', testData);
    expect(testData.errorResp).toBeDefined();
    expect(testData.errorResp).toEqual('SyntaxError: Unexpected token { in JSON at position 35');
*/
  })
}) //describe

// 
// describe('testing user input with table', () => {
//   describe.each`
//     testname | dependent_column | categorical_cols | ordinal_features | expected_cat | expected_ord
//     ${`Good input - no cat or ord`} | ${`test_class`} | ${""} | ${""} | ${[]} | ${{}}
//     ${`Good input - cat no ord`} | ${`test_class`} | ${"cat1, cat2"} | ${""} | ${["cat1","cat2"]} | ${{}}
//     ${`Good input - cat and ord`} | ${`test_class`} | ${"cat1, cat2"} | ${'{"species": ["cat", "dog", "bird"]}'}| ${["cat1","cat2"]} | ${{'species': ["cat", "dog", "bird"]}}
//     `("test good input", ({testname, dependent_column, categorical_cols, ordinal_features, expected_cat, expected_ord}) => {
//       it(`${testname}`, () => {
//         //console.log(`${testname} test`);
//
//         let store = mockStore(initialState);
//         const shallowFileUpload = shallow(<FileUpload store={store}/>).dive();
//         let fullDom;
//         let fakeFile = {target: {files: [{name: 'iris.csv'}]}};
//         const expectedInput = {
//           depCol: 'test_class',
//           catCols: ['cat1', 'cat2'],
//           ordFeats: {
//             species: ["cat", "dog", "bird"]
//           }
//         };
//
//         shallowFileUpload.setState({
//           selectedFile: fakeFile.target.files[0],
//           dependentCol: `${dependent_column}`,
//           catFeatures: `${categorical_cols}`,
//           ordinalFeatures: `${ordinal_features}`
//         });
//
//
//         // use instance to get access to inner function
//         const instance = shallowFileUpload.instance();
//         // create spy, check function gets called
//         const spy = jest.spyOn(instance, 'generateFileData');
//         const testData = instance.generateFileData(); // FormData
//         console.log(`test data: `, testData);
//         // get stuff stored in returned formdata, stingified in preparation to make
//         // network request
//         const metadata = JSON.parse(testData.get('_metadata'));
//         console.log(`test data: `, metadata);
//         expect(spy).toBeCalled();
//         // value of _metadata defined in generateFileData
//         expect(metadata.dependent_col).toEqual(`${dependent_column}`);
//         expect(metadata.categorical_features).toEqual(`${expected_cat}`);
//         expect(metadata.ordinal_features).toEqual(`${expected_ord}`);
//       })
//     })
//
//   // describe.each`
//   //   testname | dependent_column | categoricals | ordinal
//   //   ${`Good input - no cat or ord`} | ${`test_class`} | ${[]} | ${{}}
//   //   ${`Good input - no cat or ord`} | ${`test_class`} | ${"cat1, cat2"} | ${{}}
//   // `('test good input', ({testname, dependent_column, categorical, ordinal}) => {
//   //   it(`${testname}`, () => {
//   //          console.log(`${testname} test`);
//   //        })
//   // });
// })
//


// https://jestjs.io/docs/en/tutorial-async
// jest mock is not working, not returning promise, must be improperly configured and/or
// not setup correctly or something

//jest.mock('../../utils/apiHelper');
//import uploadDataset from '../../data/datasets/dataset/api';

// cheating and just importing fake apiHelper directly - probably not recommended
import { uploadFile } from '../../utils/__mocks__/apiHelper';
describe('mock network request', () => {
  let store = mockStore(initialState);
  let fullDom;

  beforeEach(() => {
    //fullDom = mount(<FileUpload store={store} testProp='hello' />);
    fullDom = shallow(<FileUpload store={store} />).dive();
  })

  const fakeDatasets = [
    {
      'name': 'auto.csv',
      'username': 'testuser',
      'dependent_col' : 'class',
      'categorical_features': '',
      'ordinal_features': '',
      'timestamp': Date.now(),
    },
    {
      'name': 'iris.csv',
      'username': 'testuser',
      'dependent_col' : 'target_class',
      'categorical_features': '',
      'ordinal_features': '',
      'timestamp': Date.now(),
    }
  ];

  it('TODO - what is this testing??? - testing promise for successful case, proper dependent_col', () => {
    expect.assertions(1); //this expects one jest assertion to be made during this test. good for testing the promises are run
    //return uploadDataset(fakeDataset).then(data => expect(data.name).toEqual('iris.csv'));
    //return uploadFile('fakeurl').then(data => expect(data.name).toEqual('iris.csv'));

    // on successful upload, change window location/redirect the page, uses error
    // flag in server response to control logic for UI to display message on error
    // or page redirection on success, not sure how to get at those pieces with
    // this testing framework. DOM does not seem to be updating correctly
    //
    //NOTE Returning a promise tells jest to wait for the promise resolution before finishing the test.
    //Test will fail if promise is rejected.
    //
    //MGS - I don't see what this is testing. It's a mock api call and has nothing to do
    // with FileUpload componenet.
    return uploadFile(fakeDatasets[0])
      .then(data => expect(data.id).toEqual(7654321));
  })

  it('testing promise for unsuccessful case, improper dependent_col', () => {
    expect.assertions(1);
    return uploadFile(fakeDatasets[1])
      .catch(e => {
        expect(e).toEqual({'error': 'dependent_col: target_class invalid'});

        // fake setting state, normally occurs in upload handler function in
        // FileUpload component after promise making actual upload resolves

        // fullDom.setState({
        //   errorResp: e,
        //   serverResp: e
        // });

        // manually setting state is not working correctly?, popup open prop should be set
        // to 'true' in case of error response, not sure if this is incorrect method
        // of testing how UI should look based on react component state

        // fullDom = shallow(<FileUpload store={store} />).dive();
        // fullDom.update();
        // let popup = fullDom.find('Popup').at(0);
        // console.log('popup props', popup.props());
      });
  })
})

// go through basic file upload flow - select file & info, upload file
// cover two scenarios - upload success and failure

// this test examines styling based on mock user input
describe('DONE - basic file upload flow with fake file', () => {

  let store = mockStore(initialState);
  let testShallow;

  beforeEach(() => {
    // https://github.com/airbnb/enzyme/issues/1002
    testShallow = shallow(<FileUpload store={store} />).dive();
    // having some trouble using mount, updating state, & checking for expected UI changes
    //fullDom = mount(<FileUpload store={store} />);
  })

  // the intended behavior of this component is to hide the fields to enter info
  // about the file being uploaded until a file with a filename has been selected
  it('DONE - check UI form is hidden w/o a file selection', () => {
    let formBody = testShallow.find('#file-upload-form-input-area');
    expect(formBody.length).toEqual(1)

    // check for CSS style which hides form
    expect(formBody.hasClass('file-upload-form-hide-inputs')).toEqual(true);
    expect(formBody.hasClass('file-upload-form-show-inputs')).toEqual(false);
  })

  it('DONE - test selecting file and displaying UI form after file selection', () => {
    // fake user submission by entering info directly into component state
    let fileName = 'iris.csv';
    let testFile = {
      name: fileName
    };
    let formBody = testShallow.find('#file-upload-form-input-area');

    // check for CSS style which hides form
    expect(formBody.hasClass('file-upload-form-hide-inputs')).toEqual(true);

    // Fake that a file has been loaded.
    // UI only checks for a valid filename field to change state of what's shown.
    testShallow.setState({
      selectedFile: testFile
    });

    // not sure but must be getting new copy of enzyme/react node with expected
    // CSS class after state changes by re-assigning variable
    formBody = testShallow.find('#file-upload-form-input-area');

    // user info is entered in form, check if form input area is visible
    // look for css styling to display form
    expect(formBody.hasClass('file-upload-form-show-inputs')).toEqual(true);
  })

})

describe('test with mock file blob', () => {
  let store = mockStore(initialState);
  let fullDom;
  let instance;

  //test blob
  let featureNames=['col1','col2','col3','class'];
  let data= featureNames.join()+`\n
            one,cat,1,yes\n
            three,dog,2,no\n
            two,cat,3,yes
            one,bird,2.5,42`;
  let filename = 'testFile.csv';
  let blob = new Blob([data], {type: 'text/csv'});
  blob.lastModifiedDate = new Date();
  let testFileBlob = new File([blob], filename);

  // Use beforeAll so that the blob stays loaded w/out having
  // to do all the tests in the mocked callback below.
  beforeAll(() => {
    fullDom = mount(<FileUpload store={store} />);
    instance = shallow(<FileUpload store={store}/>).dive().instance();
  })
  afterAll(() => {
    fullDom.unmount();
  })

  it('load simulated file blob', done => {
    // Mock the method FileUpload.handleSelectedFileCompletedStub for unit testing.
    // It gets called when file blob
    // is loaded successfully, just for unit testing since the file loader
    // calls a callback when complete, and thus otherwise wouldn't be
    // handled before this test copmletes. The 'done' method here is
    // provided by jest to handle async testing.
    // Messy but it works.
    const mockcb = jest.fn( () => { 
      // Test that it finished loading successfully
      expect(mockcb.mock.calls.length).toBe(1);
      
      // Test that the file object is set
      expect(instance.state.selectedFile.name).toEqual(filename); 

      // Tell jest we're done with this test. 
      done();       
    });
    instance.handleSelectedFileCompletedStub = mockcb;

    // Load file obj directly via handler
    instance.handleSelectedFile([testFileBlob]);
  }, 15000/* long timeout just in case*/)

  // ** NOTE **
  // Subsquent tests rely on the wrapper from above still being loaded
  // and having the test file blob loaded.

  it('test feature behaviors', () => {
      // Test the auto-assigned feature types and getFeatureType()
      expect(instance.getFeatureType(featureNames[0])).toEqual(instance.featureTypeCategorical);
      expect(instance.getFeatureType(featureNames[1])).toEqual(instance.featureTypeCategorical);
      expect(instance.getFeatureType(featureNames[2])).toEqual(instance.featureTypeNumeric);
      expect(instance.getFeatureType(featureNames[3])).toEqual(instance.featureTypeCategorical);

      // Test assigning a categorical feature to type numeric.
      // Should silently reject and not change to numeric.
      instance.setFeatureType(featureNames[0], instance.featureTypeNumeric);
      expect(instance.getFeatureType(featureNames[0])).toEqual(instance.featureTypeCategorical);

      // Get array of categorical features
      let cats = [featureNames[0],featureNames[1],featureNames[3]];
      expect(instance.getCatFeatures()).toEqual(cats);

      // Dependent column should be unset
      expect(instance.getDependentColumn()).toEqual(dep);
      
      // Assigning dependent column
      let dep = featureNames[3];
      instance.setFeatureType(dep, instance.featureTypeDependent);
      expect(instance.getFeatureType(dep)).toEqual(instance.featureTypeDependent);
      expect(instance.getDependentColumn()).toEqual(dep);
      
      // Dependent column should no longer be included as categorical
      let catsnew = [featureNames[0],featureNames[1]];
      expect(instance.getCatFeatures().find(el => el === dep)).toEqual(undefined);

      // No ordinal features should be specified. Object should be empty
      expect(Object.keys(instance.ordinalFeaturesObject).length).toEqual(0); why is ordinalFeaturesObject coming thru as undefined instead of {}??

      // Set ordinal feature, w/out specifying rank
      let ord = featureNames[0];
      instance.setFeatureType(ord, instance.featureTypeOrdinal);
      expect(instance.getFeatureType(dep)).toEqual(instance.featureTypeOrdinal);
      let uniqueVals = ['one','three','two'];
      expect(instance.ordinalFeaturesObject).toEqual({ord: uniqueVals});
      // Should not be included as a categorical feature

  })

})