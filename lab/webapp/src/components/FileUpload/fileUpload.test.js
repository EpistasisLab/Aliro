/* ~This file is part of the PennAI library~

Copyright (C) 2017 Epistasis Lab, University of Pennsylvania

PennAI is maintained by:
    - Heather Williams (hwilli@upenn.edu)
    - Weixuan Fu (weixuanf@upenn.edu)
    - William La Cava (lacava@upenn.edu)
    - Michael Stauffer (stauffer@upenn.edu)
    - and many other generous open source contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

(Autogenerated header, do not modify)

*/
import FileUpload from './';
//import SceneHeader from '../SceneHeader';
// try getting react pieces and framework for test rendering
import React from 'react';
import renderer from 'react-test-renderer';
import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import fetch from 'jest-fetch-mock';
import fetchMock from 'fetch-mock';
import Dropzone from 'react-dropzone'

const middlewares = [thunk];
const initialState = {};
const mockStore = configureStore(middlewares);

import { shallow, mount, render, configure } from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';
configure({ adapter: new Adapter() });


//// NOTE on getting state
//
// The enzyme wrapper method 'state' (and related methods) is not working on mount(<my component>).
// I think it's because the component is wrapped with redux connect().
// So you can use shallow(<my component>).dive().state(),
//  or more direclty shallow(<my component>).dive().instance().state
// I don't know which is better.
//
describe('basic testing of fileupload react component', () => {
  let store = mockStore(initialState);
  let fullDom;
  let shallowDom;
  let instance;
  let fakeFile = {name: 'iris.csv'};
  let fakeFileTsv = {name: 'iris.tsv'};
  let badFakeFile = {name: 'iris.txt'};
  // basic bookkeeping before/after each test; mount/unmount component, should be
  // similar to how piece will actually work in browser
  beforeEach(() => {
    fullDom = mount(<FileUpload store={store} testProp='hello' />);
    //NOTE with react-redux, need 'dive()' to get the 'true' (not sure of the term) component instance.
    shallowDom = shallow(<FileUpload store={store}/>).dive();
    instance = shallowDom.instance();
  })
  afterEach(() => {
    fullDom.unmount();
  })

  //test that the componement instance is viable
  //NOTE 'it' is an alias for 'test'
  it('DONE - test instance', () => {
    expect(instance).not.toEqual(null);
    //Test calling a method on the instance
    expect(instance.instanceTest()).toEqual('foobar');
    //Test retrieving state from the instance. See note above about accessing state.
    expect(instance.state.testStateValue).toEqual('foobar');
    expect(shallowDom.state('testStateValue')).toEqual('foobar');
  })

  // test for existence
  it('DONE - fileupload component, test for existence', () => {
    //console.log('jest console log!'); //this works, outputs to console at test script runtime
    // Find the component itself
    expect(fullDom.find(FileUpload)).toHaveLength(1);
    fullDom.setProps({ name: 'bar' });
    expect(fullDom.name()).toEqual('Connect(FileUpload)');
    expect(fullDom.props().testProp).toEqual('hello');
    expect(fullDom.props().name).toEqual('bar');
  })

  //snapshot of component
  //I believe shallow is better since it won't include child components
  it('DONE - full component snapshot', () => {
    expect(shallow(<FileUpload store={store}/>).dive()).toMatchSnapshot();
  })

  // the intended behavior of this component is to hide the fields to enter info
  // about the file being uploaded until a file with a filename has been selected
  it('DONE - check UI form is hidden w/o a file selection', () => {
    let formBody = shallowDom.find('#file-upload-form-input-area');
    expect(formBody.length).toEqual(1)

    // check for CSS style which hides form
    expect(formBody.hasClass('file-upload-form-hide-inputs')).toEqual(true);
    expect(formBody.hasClass('file-upload-form-show-inputs')).toEqual(false);
  })
  
  it('TODO - try selecting non-csv/tsv file type', () => {

    let dropzoneButton = fullDom.find("#file-dropzone");
    expect(dropzoneButton).toHaveLength(1);
    // Simulate callback receiving bad file obj
    dropzoneButton.at(0).prop('onDropAccepted')([badFakeFile]);
    // Should not have changed file object
    expect(shallowDom.state('selectedFile')).toBeNull();
    // Check the UI isn't showing for file specifications
    let formBody = fullDom.find('#file-upload-form-input-area');
    // check for CSS style which hides form
    expect(formBody.hasClass('file-upload-form-hide-inputs')).toEqual(true);
    expect(formBody.hasClass('file-upload-form-show-inputs')).toEqual(false);
  })
    
  //TODO - redo these
  it('TODO - try testing generateFileData - good input', () => {

  })

  it('TODO - try testing generateFileData - bad input, no ordinal features', () => {

  })

  it('TODO - try testing generateFileData - bad input, with ordinal features', () => {

  })
}) //describe


// https://jestjs.io/docs/en/tutorial-async
// jest mock is not working, not returning promise, must be improperly configured and/or
// not setup correctly or something

//jest.mock('../../utils/apiHelper');
//import uploadDataset from '../../data/datasets/dataset/api';

// cheating and just importing fake apiHelper directly - probably not recommended
import { uploadFile } from '../../utils/__mocks__/apiHelper';
describe('mock network request', () => {
  let store = mockStore(initialState);
  let fullDom;

  beforeEach(() => {
    //fullDom = mount(<FileUpload store={store} testProp='hello' />);
    fullDom = shallow(<FileUpload store={store} />).dive();
  })

  const fakeDatasets = [
    {
      'name': 'auto.csv',
      'username': 'testuser',
      'dependent_col' : 'class',
      'categorical_features': '',
      'ordinal_features': '',
      'timestamp': Date.now(),
    },
    {
      'name': 'iris.csv',
      'username': 'testuser',
      'dependent_col' : 'target_class',
      'categorical_features': '',
      'ordinal_features': '',
      'timestamp': Date.now(),
    }
  ];

  it('TODO - what is this testing??? - testing promise for successful case, proper dependent_col', () => {
    expect.assertions(1); //this expects one jest assertion to be made during this test. good for testing the promises are run
    //return uploadDataset(fakeDataset).then(data => expect(data.name).toEqual('iris.csv'));
    //return uploadFile('fakeurl').then(data => expect(data.name).toEqual('iris.csv'));

    // on successful upload, change window location/redirect the page, uses error
    // flag in server response to control logic for UI to display message on error
    // or page redirection on success, not sure how to get at those pieces with
    // this testing framework. DOM does not seem to be updating correctly
    //
    //NOTE Returning a promise tells jest to wait for the promise resolution before finishing the test.
    //Test will fail if promise is rejected.
    //
    //MGS - I don't see what this is testing. It's a mock api call and has nothing to do
    // with FileUpload componenet.
    return uploadFile(fakeDatasets[0])
      .then(data => expect(data.id).toEqual(7654321));
  })

  it('TODO check this - testing promise for unsuccessful case, improper dependent_col', () => {
    expect.assertions(1);
    return uploadFile(fakeDatasets[1])
      .catch(e => {
        expect(e).toEqual({'error': 'dependent_col: target_class invalid'});

        // fake setting state, normally occurs in upload handler function in
        // FileUpload component after promise making actual upload resolves

        // fullDom.setState({
        //   errorResp: e,
        //   serverResp: e
        // });

        // manually setting state is not working correctly?, popup open prop should be set
        // to 'true' in case of error response, not sure if this is incorrect method
        // of testing how UI should look based on react component state

        // fullDom = shallow(<FileUpload store={store} />).dive();
        // fullDom.update();
        // let popup = fullDom.find('Popup').at(0);
        // console.log('popup props', popup.props());
      });
  })
})

// Test various functionality with a file blob that
// simulates actual data loaded
describe('test with mock file blob', () => {
  let store = mockStore(initialState);
  let fullDom;
  let shallowDom;
  let instance;

  // Create a test blob.
  // Simulates raw data loaded by file I/O, before it's parsed as csv data.
  //
  let features=['col1','col2','col3','class'];
  let data= features.join()+`\n
            one,cat,1,yes\n
            three,dog,2,no\n
            two,cat,3,yes\n
            one,bird,2.5,42`;
  let catFeaturesOrig = [features[0],features[1],features[3]];
  data = data.replace(/ +?/g, ''); //Remove spaces added by multiline assignment
  let filename = 'testFile.csv';
  let blob = new Blob([data], {type: 'text/csv'});
  blob.lastModifiedDate = new Date();
  let testFileBlob = new File([blob], filename);

  function getFeatureTypesOrig(){
    return [instance.featureTypeCategorical, instance.featureTypeCategorical, instance.featureTypeNumeric, instance.featureTypeCategorical];
  }

  // Helper method so this is kept in one place
  // typeOrArray - type string to expect all to be, or 'default' for auto defaults, or array of types
  function testFeatureTypes(typeOrArray)
  {
    let testArray;
    if(Array.isArray(typeOrArray)){
      testArray = typeOrArray;
    }
    else {
      if(typeOrArray === 'default'){
        testArray = getFeatureTypesOrig();
      }
      else{
        testArray = [0,0,0,0];
        testArray.fill(typeOrArray);
      }
    }
    for( let i=0; i < 4; i++)
      expect(instance.getFeatureType(features[i])).toEqual(testArray[i]);
  }

  // Return true if error modal is showing
  function errorModalIsShowing() {
    return shallowDom.find("#error_modal_dialog").at(0).prop('open');
  }

  // Use beforeAll so that the blob stays loaded w/out having
  // to do all the tests in the mocked callback below.
  beforeAll(() => {
    fullDom = mount(<FileUpload store={store} />);
    shallowDom = shallow(<FileUpload store={store}/>).dive();
    instance = shallowDom.instance();
  })
  afterAll(() => {
    fullDom.unmount();
  })

  it('DONE - load simulated file blob', done => {
    // Mock the method FileUpload.handleSelectedFileCompletedStub for unit testing.
    // It gets called when file blob
    // is loaded successfully, just for unit testing since the file loader
    // calls a callback when complete, and thus otherwise wouldn't be
    // handled before this test copmletes. The 'done' method here is
    // provided by jest to handle async testing.
    // Messy but it works.
    const mockcb = jest.fn( () => { 
      // Test that it finished loading successfully
      expect(mockcb.mock.calls.length).toBe(1);
      
      // Test that the file object is set
      expect(instance.state.selectedFile.name).toEqual(filename); 

      // Tell jest we're done with this test. 
      done();       
    });
    instance.handleSelectedFileCompletedStub = mockcb;

    // Load file obj directly via handler
    instance.handleSelectedFile([testFileBlob]);
  }, 15000/* long timeout just in case*/)

  // ** NOTE **
  // Subsquent tests rely on the wrapper from above still being loaded
  // and having the test file blob loaded.

  it('test features states after file blob load', () => {
    // Verify error modal is not showing
    expect(errorModalIsShowing()).toBe(false);

    // Test the auto-assigned feature types and getFeatureType()
    testFeatureTypes('default');
    
    // No ordinal features should be specified. Object should be empty
    expect(instance.state.ordinalFeaturesObject).toEqual({});

    // Dependent feature should be unset after load
    expect(instance.getDependentFeature()).toEqual(undefined);
  })

  it('DONE - test feature assignment behaviors via direct manipulation', () => {
    // Test assigning a categorical feature to type numeric.
    // Should silently reject and not change to numeric.
    instance.setFeatureType(features[0], instance.featureTypeNumeric);
    expect(instance.getFeatureType(features[0])).toEqual(instance.featureTypeCategorical);

    // Test getting array of categorical features
    let catFeatures = [...catFeaturesOrig];
    expect(instance.getCatFeatures()).toEqual(catFeatures);

    // Set ordinal feature, w/out specifying rank
    let ordFeature = features[0];
    instance.setFeatureType(ordFeature, instance.featureTypeOrdinal);
    expect(instance.getFeatureType(ordFeature)).toEqual(instance.featureTypeOrdinal);
    let ordsExpected = {[ordFeature]: ["one","three","two"]};
    expect(instance.state.ordinalFeaturesObject).toEqual(ordsExpected);
    // Should not be included as a categorical feature
    catFeatures = catFeatures.filter( val => val !== ordFeature); //remove ordinal feature
    expect(instance.getCatFeatures().find(el => el === ordFeature)).toEqual(undefined);

    // Reset to default types, unset dependent, and verify
    instance.clearDependentFeature();
    instance.setAllFeatureTypes('autoDefault');
    testFeatureTypes('default');

    // Set all to ordinal
    // Note that features that default to numeric can still be set as categorical or ordinal
    instance.setAllFeatureTypes(instance.featureTypeOrdinal);
    testFeatureTypes(instance.featureTypeOrdinal);
    
    // Set all to categorical
    instance.setAllFeatureTypes(instance.featureTypeCategorical);
    testFeatureTypes(instance.featureTypeCategorical);

    // Set all to numeric
    // This should not set default-categorical types to numeric. They should be left as-is.
    instance.setAllFeatureTypes(instance.featureTypeNumeric);
    testFeatureTypes('default'); // Should now all equal default types because of how I've structured the test up to here

    // Invalid feature names should be handled properly
    expect(instance.validateFeatureName('The Spanish Inquisition')).toEqual(false);
    // Should return default type for invalid feature name
    expect(instance.getFeatureType('xkcd4eva')).toEqual(instance.featureTypeDefault);
    expect(instance.getFeatureDefaultType('Frank the Furter')).toEqual(instance.featureTypeDefault);
  })

  it('DONE - test dependent feature and prediction type behaviors via direct manipulation', () => {
    //Reset feature types
    instance.clearDependentFeature();
    instance.setAllFeatureTypes('autoDefault');
    
    // Dependent feature should be unset
    expect(instance.getDependentFeature()).toEqual(undefined);
    
    // Assigning dependent feature
    let dep1 = features[2];
    instance.setFeatureType(dep1, instance.featureTypeDependent);
    expect(instance.getFeatureType(dep1)).toEqual(instance.featureTypeDependent);
    expect(instance.getDependentFeature()).toEqual(dep1);
    
    // Reassigning dependent feature should reset the previous one
    // to its default type
    let dep2 = features[3];
    instance.setFeatureType(dep2, instance.featureTypeDependent);
    expect(instance.getFeatureType(dep2)).toEqual(instance.featureTypeDependent);
    expect(instance.getDependentFeature()).toEqual(dep2);
    expect(instance.getFeatureType(dep1)).toEqual(instance.getFeatureDefaultType(dep1));

    // Dependent column should no longer be included as categorical
    //expect(instance.getCatFeatures().find(el => el === dep2)).toEqual(undefined);
    expect(instance.getCatFeatures()).not.toContain(dep2);

    // Prediction type - should be set to default
    expect(instance.state.predictionType).toEqual(instance.defaultPredictionType);
  })

  // Test the methods used by the dialogs for text-based specification of
  // feature types and ordinal ranking
  it('test text-based categorical-type specification', () => {
    //Reset feature types to dfault
    instance.clearDependentFeature();
    instance.setAllFeatureTypes('autoDefault');

    // Get the text input element
    let textInput = shallowDom.find("#categorical_features_text_area_input");
    expect(textInput.length).toEqual(1);

    // Simulate entering text and then accepting it
    function updateText(text) {
      let event = {target: {value: text}};
      textInput.at(0).prop('onChange')(event); // stores text to state
      textInput.at(0).prop('onBlur')(event); // stores text as raw to state
      shallowDom.find("#cat_features_user_text_accept_button").at(0).simulate('click'); //uses state vars
      shallowDom.update();
    }

    // Should all be default still after empty string
    updateText("");
    expect(errorModalIsShowing()).toBe(false);
    testFeatureTypes('default');

    // Assign single feature (that's already categorical) via text. 
    // This shouldn't change anything because other features that default to categorical
    // will stay as such.
    updateText(catFeaturesOrig[0]); 
    expect(errorModalIsShowing()).toBe(false);
    testFeatureTypes('default');

    // Assign all as categorical by passing string 'col1,col2,col3,class'
    updateText(features.join());
    expect(errorModalIsShowing()).toBe(false);
    testFeatureTypes(instance.featureTypeCategorical);

    // Assign just default-categorical again, and the one default-numeric feature
    // should revert to numeric
  /* TODO needs merge from FileUploadUiTweaksNew branch that fixes bug
    updateText(features.join()); // set all to type cat
    updateText(catFeaturesOrig.join()); // leaves out those not cat by default
    expect(errorModalIsShowing()).toBe(false);
    testFeatureTypes('default');
  */

    // Reset
    instance.setAllFeatureTypes('autoDefault');

    // Test with range - set all to categorical
    updateText(features[0]+"-"+features[3]);
    expect(errorModalIsShowing()).toBe(false);
    testFeatureTypes(instance.featureTypeCategorical);

    // Test with smaller range. Should set all to categorical
    instance.setAllFeatureTypes(instance.featureTypeOrdinal);
    updateText(features[0]+","+features[1]+"-"+features[2]+","+features[3]);
    expect(errorModalIsShowing()).toBe(false);
    testFeatureTypes(instance.featureTypeCategorical);
    
    // Test with bad string. Should see error modal and unchanged feature types
    updateText("woogie woogie");
    expect(errorModalIsShowing()).toBe(true);
    testFeatureTypes(instance.featureTypeCategorical);

  })
})

//TODO
// Test UI contents (eg table has right entries)
// Test behaviors via UI interaction simulation
// Test textual input for cat and ord feature specifications
// Test submit behavior and validation - incl. generateFileData method