/* ~This file is part of the Aliro library~

Copyright (C) 2023 Epistasis Lab, 
Center for Artificial Intelligence Research and Education (CAIRE),
Department of Computational Biomedicine (CBM),
Cedars-Sinai Medical Center.

Aliro is maintained by:
    - Hyunjun Choi (hyunjun.choi@cshs.org)
    - Miguel Hernandez (miguel.e.hernandez@cshs.org)
    - Nick Matsumoto (nicholas.matsumoto@cshs.org)
    - Jay Moran (jay.moran@cshs.org)
    - and many other generous open source contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

(Autogenerated header, do not modify)

*/
//require('es6-promise').polyfill();
//import fs = require('fs');
import { connect } from 'react-redux';
import React, { Component } from 'react';
import ReactDOM from "react-dom";
import { fetchDatasets } from '../../data/datasets/actions';
import { uploadDataset } from '../../data/datasets/dataset/actions';
import SceneHeader from '../SceneHeader';
import Papa from 'papaparse';



import {
  Button,
  Dropdown,
  Form,
  Segment,
  Table,
  Popup,
  Header,
  Icon,
  Divider,
  Modal,
  Menu,
  Grid,
  Loader
} from 'semantic-ui-react';
// dropzone and userdropzone
import Dropzone,{useDropzone} from 'react-dropzone';
import {SortableContainer, SortableElement} from 'react-sortable-hoc';
import arrayMove from 'array-move';



class FileUpload extends Component {

  
  
  //Some pseudo-constants to avoid typos
  get featureTypeNumeric() { return 'numeric'; }
  get featureTypeCategorical() { return 'categorical'; }
  get featureTypeOrdinal() { return 'ordinal'; }
  /** Special type to mark the dependent column. 
   *  It's not properly a feature, but use same terminology for consistency. */
  get featureTypeDependent() { return 'dependent'; }
  //Type to return in case of errors
  get featureTypeDefault() {return this.featureTypeNumeric; }

  /**
  * FileUpload reac component - UI form for uploading datasets
  * @constructor
  */
  constructor(props) {
    super(props);

    this.state = this.initState;

    // enter info in text fields
    // this.cleanOtherTooltipFunction = this.cleanOtherTooltipFunction.bind(this);

    // this.tooltipFileUploadFunction = this.tooltipFileUploadFunction.bind(this);

    this.resetState = this.resetState.bind(this);
    this.handleDepColDropdown = this.handleDepColDropdown.bind(this);
    this.handleCatFeaturesUserTextOnChange = this.handleCatFeaturesUserTextOnChange.bind(this);
    this.handleCatFeaturesUserTextBlur = this.handleCatFeaturesUserTextBlur.bind(this);
    this.handleCatFeaturesUserTextAccept = this.handleCatFeaturesUserTextAccept.bind(this);
    this.handleCatFeaturesUserTextCancel = this.handleCatFeaturesUserTextCancel.bind(this);
    this.handleOrdinalFeaturesUserTextAccept = this.handleOrdinalFeaturesUserTextAccept.bind(this);
    this.handleOrdinalFeaturesUserTextCancel = this.handleOrdinalFeaturesUserTextCancel.bind(this);
    this.handleOrdinalFeaturesUserTextOnChange = this.handleOrdinalFeaturesUserTextOnChange.bind(this);
    this.handlePredictionType = this.handlePredictionType.bind(this);
    this.getHeaderRowCells = this.getHeaderRowCells.bind(this);
    this.getDataTablePreview = this.getDataTablePreview.bind(this);
    this.getDataTableOrdinalRankButton = this.getDataTableOrdinalRankButton.bind(this);
    this.generateFileData = this.generateFileData.bind(this);
    this.handleErrorModalClose = this.handleErrorModalClose.bind(this);
    this.showErrorModal = this.showErrorModal.bind(this);
    this.handleFeatureTypeDropdown = this.handleFeatureTypeDropdown.bind(this);
    this.initDatasetPreview = this.initDatasetPreview.bind(this);
    this.handleOrdinalSortDragRelease = this.handleOrdinalSortDragRelease.bind(this);
    this.handleOrdinalRankClick = this.handleOrdinalRankClick.bind(this);
    this.handleOrdinalSortAccept = this.handleOrdinalSortAccept.bind(this);
    this.handleOrdinalRankCancel = this.handleOrdinalRankCancel.bind(this);
    this.getUniqueValuesForFeature = this.getUniqueValuesForFeature.bind(this);
    this.getFeatureDefaultType = this.getFeatureDefaultType.bind(this);
    this.ordinalFeaturesClearToDefault = this.ordinalFeaturesClearToDefault.bind(this);
    this.ordinalFeaturesObjectToUserText = this.ordinalFeaturesObjectToUserText.bind(this);
    this.validateFeatureName = this.validateFeatureName.bind(this);
    this.getUserFeatureTypeControls = this.getUserFeatureTypeControls.bind(this);
    this.getUserDatasetOptions = this.getUserDatasetOptions.bind(this);
    this.getFeatureType = this.getFeatureType.bind(this);
    this.getFeatureIndex = this.getFeatureIndex.bind(this);
    this.catFeaturesUserTextValidateAndExpand = this.catFeaturesUserTextValidateAndExpand.bind(this);
    this.getCatFeatures = this.getCatFeatures.bind(this);
    this.setAllFeatureTypes = this.setAllFeatureTypes.bind(this);
    this.parseFeatureToken = this.parseFeatureToken.bind(this);
    this.initFeatureTypeDefaults = this.initFeatureTypeDefaults.bind(this);
    this.getDependentColumn = this.getDependentColumn.bind(this);
    this.clearDependentFeature = this.clearDependentFeature.bind(this);
    this.getElapsedTime = this.getElapsedTime.bind(this);
    this.getOridinalRankingDialog = this.getOridinalRankingDialog.bind(this);
    this.getOrdinalFeaturesUserTextModal = this.getOrdinalFeaturesUserTextModal.bind(this);
    this.getCatFeaturesUserTextModal = this.getCatFeaturesUserTextModal.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.enableKeyDownHandler = this.enableKeyDownHandler.bind(this);
    this.initDependentColumn = this.initDependentColumn.bind(this);

    //this.cleanedInput = this.cleanedInput.bind(this)

    this.defaultPredictionType = "classification"

    // help text for dataset upload form - dependent column, categorical & ordinal features
    this.depColHelpText = `The column that describes the label or output for each row.
    For example, if analyzing a dataset of patients with different types of diabetes,
    this column may have the values "type1", "type2", or "none".`;

    this.predictionTypeHelp = (<p><i>Classification</i> algorithms are used to model discrete categorical outputs.
      Examples include modeling the color car someone might buy ("red", "green", "blue"...) or a disease state ("type1Diabetes", "type2Diabetes", "none"...)
   <br/><br/><i>Regression</i> algorithms are used to model a continuous valued output.  Examples include modeling the amount of money a house is predicted to sell for.</p>);

    this.catFeatHelpText = (<p>This site is using 'Categorical' to mean a Nominal feature, per custom in the ML community. Categorical features have a discrete number of categories that do not have an intrinsic order.
    Some examples include sex ("male", "female") or eye color ("brown", "green", "blue"...).
    <br/><br/>
    You can specify these features in two ways:<br/>
    1) In the text input box opened by the button to the left, using the format described in the box <br/>
    2) or, in the Dataset Preview table below: use the dropdown boxes to specify categorical features.</p>);

    this.ordFeatHelpText = (<p>Ordinal features have a discrete number of categories,
    and the categories have a logical order (rank). Some examples include size ("small",
    "medium", "large"), or rank results ("first", "second", "third").
    <br/><br/>
    You can specify these features and their rank in two ways:<br/>
    1) In the text input box opened by the button to the left, using the format described in the box <br/>
    2) or, in the Dataset Preview table below: use the dropdown boxes to specify ordinal features, then rank them
    using the drag-and-drop list of unique categories.</p>);

    //Debug
    this.isDevBuild = (!process.env.NODE_ENV || process.env.NODE_ENV === 'development');
    this.timingPrevTimeMsec = new Date().getTime();
  }

  


  cleanOtherTooltipFunction() {
    console.log("Fron app test");


    var interval = setInterval(function() {

      // if there is span id with span_upload_dataset then make it not visible
      // current href
      var current_href = window.location.href;
      // current href does not include upload_
      // if (current_href.includes("upload_") == false) 
      if (document.getElementById("span_test")!=null && current_href.includes("upload_") == true) {
        // remove the span_upload_dataset
        // var elem = document.getElementById("span_upload_dataset");
        // elem.parentNode.removeChild(elem);
        // document.getElementById("div_tooltip_file_upload").remove();

        console.log("span_test exists and this is not first page");



        // remove span_test
        var elem_Sec = document.getElementById("span_test");
        elem_Sec.parentNode.removeChild(elem_Sec); 

        
      }


    }, 500);

  }


  tooltipFileUploadFunction() {

    // console.log("Page File upload!!!!")

    // wait until div class name with dropzone is loaded
    var interval = setInterval(function() {

      // div_tooltip_file_upload id 
      var div_tooltip_file_upload = document.getElementById("div_tooltip_file_upload");

      // find id with span_upload_dataset
      var span_upload_dataset = document.getElementById("span_upload_dataset");

      
      // current href
      const current_href = window.location.href;
      

      // if(document.getElementsByClassName("dropzone").length > 0 && span_upload_dataset == null)  {
      if(div_tooltip_file_upload == null  && span_upload_dataset == null && current_href.includes("upload_")==true)  {
        clearInterval(interval);
        // console.log("Page File upload!!!!")
        

        // const x = document.getElementById("app");
        // find any elements with the tag name "a" with Hello Add new"
        const y = document.getElementsByClassName("dropzone");

        // make mouseover event for y





        // console.log("y")
        // console.log(y)


        var styles_v3 = 
        `
      .tooltip {
        position: relative;
        display: inline-block;
        border-bottom: 1px dotted black;
      }
      
      .tooltip .tooltiptext {
        visibility: visible;
        width: 120px;
        background-color: #555;
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        bottom: 500%;
        left: 970%;
        margin-left: 0px;
        opacity: 1;
        transition: opacity 0.3s;
      }
      
      .tooltip .tooltiptext::after {
        content: "";
        position: absolute;
        top: 30%;
        left: -8.3%;
        margin-left: 0px;
        border-width: 5px;
        border-style: solid;
        border-color: transparent #555 transparent transparent;
      }
      
      .tooltip:hover .tooltiptext {
        visibility: hidden;
        opacity: 0;
      `

      
    


      if (document.getElementsByTagName("style").length == 1) {
      
        // console.log("show how many style tags: ", document.getElementsByTagName("style").length);
        // console.log("style tag already exists");

        // remove the all current style tags
        var elem = document.getElementsByTagName("style");

        for (var i = 0; i < elem.length; i++) {
          elem[i].parentNode.removeChild(elem[i]);
        }

        var styleSheet = document.createElement("style")
        styleSheet.innerText = styles_v3
        document.head.appendChild(styleSheet)
      
      }

      // <div class="tooltip">Hover over me
          // <span class="tooltiptext">Tooltip text</span>
      // </div>


      // append div_test to app
      const x = document.getElementById("app");
      // get body
      const body = document.getElementsByTagName("body")[0];



      // create a div with class tooltip and html content "Hover over me"
      var div_test = document.createElement("div");
      div_test.id = "div_tooltip_file_upload";
      div_test.className = "tooltip";
      // div_test.innerHTML = "Hover over me";
      div_test.innerHTML = "HelloHello";
      // male the innerHTML color #1b1d1c
      div_test.style.color = "#1b1d1c";
      // background color is white
      // div_test.style.backgroundColor = "white";
      div_test.style.backgroundColor = "#1b1d1c";
      // make div_test transparent
      // div_test.style.opacity = "0.5";
      // do not show div_test
      // div_test.style.display = "none";

      // create a span with class tooltiptext and html content "Tooltip text"
      var span_test = document.createElement("span");
      // set id to span_test
      span_test.id = "span_upload_dataset";
      span_test.className = "tooltiptext";
      span_test.innerHTML = "Step 2: Click on the button to upload your dataset";

      // make span_test always visible
      span_test.style.visibility = "visible";



      // make span_test always block whever div_test is hovered or not
      span_test.style.display = "block";
      

      // append span_test to div_test
      div_test.appendChild(span_test);


      // x.appendChild(div_test);

      
      
      // x.appendChild(span_test);
      body.appendChild(div_test);


      const section_ele = document.getElementsByTagName("section")[0];
      // find any div with class name ui segment file-upload-segment
      const div_ele = document.getElementsByClassName("ui segment file-upload-segment")[0];
      
      // find any div whose class name includes "file-upload-segment"

      // console.log("document.getElementById(span_upload_dataset")
      // console.log(document.getElementById("span_upload_dataset"));

      var catch_null = document.getElementById("span_upload_dataset");
      console.log("catch_null")
      console.log(catch_null)

      var flag_remove=0;

    
      // replace onclick with mouseover
      div_ele.onmouseover = function() {
        console.log("Mouse over dropzone");
        if (catch_null != null) {
        document.getElementById("span_upload_dataset").style.visibility = "hidden";    
        }  
      } 

      div_ele.onmouseout = function() {
        console.log("Mouse out dropzone");
        if (catch_null != null && flag_remove==0) {
        document.getElementById("span_upload_dataset").style.visibility = "visible";   
      }     
     }

      div_ele.onclick = function() {
        console.log("Mouse click dropzone");
        if (catch_null != null) {
        // document.getElementById("span_upload_dataset").style.visibility = "hidden";     
        
        // remove document.getElementById("span_upload_dataset") 
        // document.getElementById("span_upload_dataset").remove();
        flag_remove = 1;

        }
      }
    
    

  //   div_ele.onmouseover = function() {
  //     console.log("Mouse over dropzone");
  //     document.getElementById("span_upload_dataset").style.visibility = "hidden";      
  //   } 

  //   div_ele.onmouseout = function() {
  //     console.log("Mouse out dropzone");
  //     document.getElementById("span_upload_dataset").style.visibility = "visible";      
  // }

  //   div_ele.onclick = function() {
  //     console.log("Mouse click dropzone");
  //     // document.getElementById("span_upload_dataset").style.visibility = "hidden";     
      
  //     // remove document.getElementById("span_upload_dataset") 
  //     document.getElementById("span_upload_dataset").remove();
  //   }



    

      }
    }, 300);



    // setTimeout(() => {
    //   //wait until the section is loaded
    //   const section = document.getElementsByTagName("section")[0];
    
    //         if (section) {
    //           section.addEventListener("mouseover", function( event ) {
    //         // console.log("mouseover on dropzone");
  
    //         // document.getElementById("span_upload_dataset").style.visibility = "hidden";
    //         if (document.getElementById("span_upload_dataset").style.visibility == "hidden")
    //         {
    //           document.getElementById("span_upload_dataset").style.visibility = "visible";
    //           console.log("document.getElementById(span_upload_dataset).style.visibility = visible");
    //         }
    //         else
    //         {
    //           document.getElementById("span_upload_dataset").style.visibility = "hidden";
    //           console.log("document.getElementById(span_upload_dataset).style.visibility = hidden");
    //         }
            
    //         // span_test.style.visibility = "hidden";
          
    //       }, false);
    //     }
    // }, 1000); 


   

    

    // document.addEventListener("DOMContentLoaded", function(e) {
    //   console.log("Page File upload!!!!")

    //   setTimeout(function() {
    //     // get any divs with class dropzone
    //     const x = document.getElementsByClassName("dropzone");
    //     console.log(x)

    //     // get any divs with class dropzone
    //     for (var i = 0; i < x.length; i++) {
    //       console.log(x[i])
    //       // add .appendChild(span_test);
          
    //     }
    //   }, 2000);
    // } );
  }


  get initState() {
    // this.cleanOtherTooltipFunction();
    // this.tooltipFileUploadFunction();

    return {
      selectedFile: null,
      /** Flag tells us when a file is being loaded and processed for preview. */
      processingFileForPreview: false,
      /** The dataset object for preview, read from file */
      datasetPreview: null,
      /** Show the model error dialog */
      showErrorModal: false,
      /** {array} String-array holding the type for each feature, in same index order as features within the data. 
       * For assignment, use the gettors:
       *  featureTypeNumeric, featureTypeCategorical,  featureTypeOrdinal, featureTypeDependent }
      */
      featureType: [],
      /** {object} Object with proerty for each feature, holding the auto-determined default feature type for each feature. */
      featureTypeDefaults: {},
      /** {string} Text the the text box for user to optionally enter categorical feature specifications. 
       *  Must be kept in sync with the settings featureType state array. */
      catFeaturesUserText: '',
      /** Raw user text input that may contain feature ranges. Save this to show when appropriate. */
      catFeaturesUserTextRaw: '',
      /** Flag to control modal dialog for categorical user text input */
      catFeaturesUserTextModalOpen: false,
      /** {string} Text from the text box for user to optionally enter ordinal feature specifications.
       *  Must be kept in sync with ordinalFeaturesObject */
      ordinalFeaturesUserText: '',
      ordinalFeaturesUserTextModalOpen: false,
      /** {object} Object used as dictionary to track the features designated as ordinal by user via dataset preview UI.
       *  key: feature name from dataPreview
       *  value: string-array holding possibly-ordered unique values for the feature.
       *  Will be empty object if none defined.
       *  Gets updated with new order as user orders them using the UI in dataset preview.
       *  Using objects as dictionary: https://pietschsoft.com/post/2015/09/05/javascript-basics-how-to-create-a-dictionary-with-keyvalue-pairs
       */
      ordinalFeaturesObject: {},
      /** Holds previous versions of ordinal feature value orderings, so that they can be restored if 
       *  user has defined them, then changed feature type, then goes back to type ordinal.
       */
      ordinalFeaturesObjectPrev: {},
      /** {string} The ordinal feature that is currently being ranked by sortable list, when sortable list is active. */
      ordinalFeatureToRank: undefined,
      /** {array} Array of unique (and possibly sorted) values for the ordinal feature currently being ranked. This gets
       *  modified while user is ranking the values, and then stored to state if user finalizes changes. */
      ordinalFeatureToRankValues: [],
      allFeaturesMenuOpen: false,
      predictionType: this.defaultPredictionType,
      /** {string} Used in unit testing to test state retrieval */
      testStateValue: 'foobar'
    }
  }




  /** Reset the state to its default, clearing any loaded data. */
  resetState() {
    this.setState(this.initState);
  }

  /**
  * React lifecycle method, when component loads into html dom, 'reset' state
  */
  componentDidMount() {
    this.resetState(); //Not sure why this is called here
    //Add listener for keystrokes so we can process esc key globablly.
    this.enableKeyDownHandler(true);
  }

  componentWillUnmount(){
    //Supposedly if we don't remove the listener we can get memory leaks
    this.enableKeyDownHandler(false);
  }

  enableKeyDownHandler(enable){
    if(enable){
      //Do this with a delay because otherwise any events (e.g. from modal error dialog)
      // meant to be handled by a proper modal dialog will also be handled by this handler,
      // which we don't want.
      setTimeout(() => {document.addEventListener("keydown", this.handleKeyDown, false);}, 100);
    }
    else {
      document.removeEventListener("keydown", this.handleKeyDown, false);
    }
  }

  /** Special document-wide key event handler */
  handleKeyDown(event){
    //handle escape key to close our pseudo-modal dialogs.
    if(event.keyCode === 27 ) {
      this.handleOrdinalRankCancel();
      this.handleOrdinalFeaturesUserTextCancel();
      this.handleCatFeaturesUserTextCancel();
    }
  }

  /** Simple test method for unit testing */
  instanceTest(){
    return 'foobar';
  }
  
  /** Helper routine for debugging. Get elapsed time in sec from 
   * either init or from the previous call to this method.
   */
  getElapsedTime() {
    let res = ((new Date().getTime()) - this.timingPrevTimeMsec)/1000;
    this.timingPrevTimeMsec = new Date().getTime();
    return res;
  }

  /**
   * Text field for entering dependent column, sets component react state with
   * user input
   * @param {Event} e - DOM Event from user interacting with UI text field
   * @param {Object} props - react props object
   * @returns {void} - no return value
   */
  handleDepColDropdown(e, data) {
    //window.console.log('safe input: ', safeInput);
    //console.log("dep col value: " + data.value);

    // This will reset feature type for a dependent column that's already set
    this.setFeatureType(data.value, this.featureTypeDependent);
  }

  /**
   * text field/area for entering categorical features
   * user input
   * @param {Event} e - DOM Event from user interacting with UI text field
   * @returns {void} - no return value
   */
  handleCatFeaturesUserTextOnChange(e) {
    //window.console.log('safe input cat: ', safeInput);
    this.setState({
      catFeaturesUserText: e.target.value,
    });
  }

  handleCatFeaturesUserTextBlur(e) {
    //Save this show we can show it in user text box when it evaluates to the same
    // settings as current categorical feature set. 
    //Handling here in blur also handles case where user doesn't edit text but just hits accept.
    this.setState({catFeaturesUserTextRaw: e.target.value});
  }

  /** Process the passed string and update Categorical feature settings.
   *  Assumes the input string has been validated.
   *  Will override any settings made via feature-type dropdowns selectors
   *  by setting any current Categorical features to their default type,
   *  EXCEPT that any fields that are auto-detected as type Categorical will
   *  stay as type Categorical even if not listed in the input string.
   */ 
  catFeaturesUserTextIngest(input) {
    //First take all current cat features and set them to their auto-defaults.
    //This is necessary for condition when user unassigns a cat feature via new input.
    this.getCatFeatures().forEach( feature => {
      this.setFeatureType(feature, this.getFeatureDefaultType(feature));
    })
    //Now set cat features from the input string
    if(input != "") {
      input.split(',').forEach( (feature) => {
        this.setFeatureType(feature.trim(), this.featureTypeCategorical);
      })
    }
  }

  /** Handler for accepting button to accept categorical feature user text element.
   *  Examine and validate the contents. 
   *  If valid, ingest the text and update the categorical features.
   *  If invalid, show an error message.
   * @param {Event} e - DOM Event from user interacting with UI text field
   * @returns {void} - no return value
  */
  handleCatFeaturesUserTextAccept(e) {
    //Validate the whole text. Handles empty strings cleanly.
    let result = this.catFeaturesUserTextValidateAndExpand(this.state.catFeaturesUserText);
    if( result.success ) {
      this.catFeaturesUserTextIngest(result.expanded);
      //Close the user text dialog
      this.setState({catFeaturesUserTextModalOpen: false})
    }
    else {
      //On error, the modal window showing the text input will stay open, so user
      // must either cancel or correct the error
      this.showErrorModal("Error in Categorical Feature text entry", result.message);
      console.log("Error validating categorical feature user text: " + result.message);
    }
  }

/** Handle cancel button for user text input for categorical features.
 * Will reset the state string to the current state from getCatFeatures()
 */
handleCatFeaturesUserTextCancel() {
  this.setState({
    catFeaturesUserText: this.getCatFeatures().join(),
    catFeaturesUserTextModalOpen: false,
  })
}

  /** Handler for accepting button to accept oridinal feature user text element.
   *  Examine and validate the contents. 
   *  If valid, ingest the text and update the ordinal features.
   *  If invalid, show an error message.
   * @param {Event} e - DOM Event from user interacting with UI text field
   * @returns {void} - no return value
  */
  handleOrdinalFeaturesUserTextAccept(e) {
    //Validate the whole text
    let result = this.ordinalFeaturesUserTextValidate();
    if( result.success ) {
      this.ordinalFeaturesUserTextIngest();
      this.setState({ordinalFeaturesUserTextModalOpen: false})
    }
    else {
      //On error, the modal window showing the text input will stay open, so user
      // must either cancel or correct the error
      this.showErrorModal("Error in Ordinal Feature text entry", result.message);
      console.log("Error validating ordinal feature user text: " + result.message);
    }
  }

  /** Handle cancel but for ordinal user text modal. 
   *  Resets ordinalFeaturesUserText to state from ordinalFeaturesObject */
  handleOrdinalFeaturesUserTextCancel() {
    this.setState({
      ordinalFeaturesUserText: this.ordinalFeaturesObjectToUserText(),
      ordinalFeaturesUserTextModalOpen: false,
    })
  }

  /** Handle text change in the ordinal features user text input. 
   *  Simply stores the current value for use if user accepts the input. */
  handleOrdinalFeaturesUserTextOnChange(e) {
    this.setState({
      ordinalFeaturesUserText: e.target.value,
    });
  }

  handlePredictionType(e, data) {
    this.setState({
      predictionType: data.value,
    });
  }

  /**
   * Helper method to consolidate user input to send with file upload form.
   * Does some validation of inputs.
   * @returns {FormData} - FormData object containing user input data
   */
  generateFileData = () => {
    const allowedPredictionTypes = ["classification", "regression"]

    const data = new FormData();
    let depCol = this.getDependentColumn();
    let ordFeatures = "";
    let predictionType = this.state.predictionType;

    if(this.state.selectedFile && this.state.selectedFile.name) {
      // get raw user input from state

      //Check predication type
      if (!allowedPredictionTypes.includes(predictionType)) {
        return { errorResp: `Invalid prediction type: ${predictionType}`};
      }

      //Check that dependent column is valid
      if (!this.validateFeatureName(depCol)) {
        return { errorResp: "Please assign a Target Column." };
      }

      // Ordinal features. 
      // If none are specified, pass empty string to the output, per
      //  original behavior
      if(Object.keys(this.state.ordinalFeaturesObject).length !== 0 ) {
        ordFeatures = this.state.ordinalFeaturesObject;
      }

      // Categorical feature assignments.
      // Array of string names of categorical features. Can be empty.
      let catFeaturesAssigned = this.getCatFeatures();

      // keys specified for server to upload repsective fields,
      // filter
      let metadata =  JSON.stringify({
                'name': this.state.selectedFile.name,
                'username': 'testuser',
                'timestamp': Date.now(),
                'dependent_col' : depCol,
                'prediction_type' : predictionType,
                'categorical_features': catFeaturesAssigned,
                'ordinal_features': ordFeatures
              });

      data.append('_metadata', metadata);

      data.append('_files', this.state.selectedFile);
      // before upload get a preview of what is in dataset file

      //debug output in dev build
      if (this.isDevBuild) {
        console.log("Dev build debug out. metadata: ");
        console.log(metadata);
      }

      //window.console.log('preview of uploaded data: ', dataPrev);
      // after uploading a dataset request new list of datasets to update the page
    } else {
      window.console.log('generateFileDate: no file available');
      return { errorResp: "No file is available." };
    }

    return data;
  }

  /**
   * Event handler for showing message when unsupported filetype is selected for upload by user.
   * @param {Array} fileObj - array of rejected files (we only expect one, and use just the first)
   * @returns {void} - no return value
   */
  handleRejectedFile = files => {
    console.log('Filetype not csv or tsv:', files[0]);
    this.setState({
      selectedFile: null,
      datasetPreview: null,
    });
    this.showErrorModal("Invalid file type chosen", "Please choose .cvs or .tsv files");
  }

  /**
   * Called when a new dataset has been loaded for preview.
   * Do whatever needs to be done.
   * @returns {void} - no return value
   */
  initDatasetPreview = () => {
    let dataPrev = this.state.datasetPreview;
    //Init oridinal values
    this.ordinalFeaturesClearToDefault();  
    //Init the store of default feature types
    this.initFeatureTypeDefaults();
    //Init the default dependent column.
    //Do this before setAllFeatureTypes
    this.initDependentColumn();
    //Init the feature type assignments
    this.setAllFeatureTypes('autoDefault');
    //Clear 
    this.setState({processingFileForPreview: false});
  }

  /** Stub method that's mocked in unit testing */
  handleSelectedFileCompletedStub(){
    //do nothing
  }

  /**
   * Event handler for selecting files, takes user file from html file input, stores
   * selected file in component react state, generates file preview and stores that
   * in the state as well. If file is valid does the abovementioned, else error
   * is generated
   * @param {Array} fileObj - array of selected files (we only expect one, and use just the first)
   * @returns {void} - no return value
   */


  handleSelectedFile = files => {

    console.log("handleSelectedFile")
    if (files !=null)
    {
      console.log("it is null")
      console.log(files)
    }
    const fileExtList = ['csv', 'tsv'];
    //Config for csv reader. We load the whole file so we can let user sort the ordinal features
    let papaConfig = {
      header: true,
      complete: (result) => {
        //window.console.log('preview of uploaded data: ', result);
        if(this.isDevBuild) {
          console.log( this.getElapsedTime() + " - papaConfig complete. Calling setState... ");
        }
        //Store the result
        this.setState({datasetPreview: result});

        if(this.isDevBuild){
          console.log( this.getElapsedTime() + " - setState complete. ");
          console.log("Calling initDatasetPreview... ");
          this.getElapsedTime();
        }
        
        //Init things for the new dataset
        this.initDatasetPreview();
  
        if(this.isDevBuild)
          console.log( this.getElapsedTime() + " - done with initDatasetPreview.");

        //Call this method for use in unit testing, to know we've completed successfully here,
        // and can inspect the new state
        this.handleSelectedFileCompletedStub();
      }
    };

    // check for selected file
    if(files && files[0]) {
      // immediately try to get dataset preview on file input html element change
      // need to be mindful of garbage data/files
      let uploadFile = files[0]
      let fileExt = uploadFile.name.split('.').pop();

      // check file extensions
      if (fileExtList.includes(fileExt)) {
        // use try/catch block to deal with potential bad file input when trying to
        // generate file/csv preview, use filename to check file extension
        try {
          if(this.isDevBuild) {
            this.getElapsedTime(); //resets the timer
            console.log("=== DevBuild output - Calling Papa.parse... ");
          }
          Papa.parse(uploadFile, papaConfig);
        }
        catch(error) {
          console.error('Error generating preview for selected file:', error);
          this.setState({
            selectedFile: null,
            datasetPreview: null,
            showErrorModal: false,
            processingFileForPreview: false
          });
          this.showErrorModal("Error With File", JSON.stringify(error));
          //Added this return, otherwise it will fall through to state below
          return;
        }

        //NOTE - this code is reached before the papaConfig.complete callback is called,
        // so if file is parsed successfully, the datasetPreview property will be set
        this.setState({
          selectedFile: files[0],
          datasetPreview: null,
          showErrorModal: false,
          processingFileForPreview: true
        });

      } else {
        console.log('Filetype not csv or tsv:', uploadFile);
        this.setState({
          selectedFile: null,
          datasetPreview: null,
          showErrorModal: true,
          processingFileForPreview: false
        });
      }
    } else {
      // reset state as fallback
      this.resetState();
    }
  }

  /**
   * Starts download process, takes user input, creates a request payload (new html Form)
   * and sends data to server through redux action, uploadDataset, which is a promise.
   * When promise resolves update UI or redirect page depending on success/error.
   * Upon error display error message to user, on success redirect to dataset page
   * @returns {void} - no return value
   */
  handleUpload = (event) => {
    console.log("hanleupload running")

    
    if (this.state.uploadButtonDisabled) {
      return;
    }
    this.setState({uploadButtonDisabled:true});

    const { uploadDataset } = this.props;
    // only attempt upload if there is a selected file with a filename
    if(this.state.selectedFile && this.state.selectedFile.name) {
      let data = this.generateFileData(); // should be FormData
      // if trying to create FormData results in error, don't attempt upload
      if (data.errorResp) {
        this.showErrorModal("Error with file metadata", data.errorResp);
        //Reenable upload button since this error messge is blocking
        this.setState({uploadButtonDisabled:false});
      } else {
        // after uploading a dataset request new list of datasets to update the page
        uploadDataset(data).then(stuff => {
          //window.console.log('FileUpload props after download', this.props);
          //let resp = Object.keys(this.props.dataset.fileUploadResp);
          let resp = this.props.dataset.fileUploadResp;
          let errorRespObj = this.props.dataset.fileUploadError;

          // if no error message and successful upload (indicated by presence of dataset_id)
          // 'refresh' page when upload response from server is not an error and
          // redirect to dataset page, when error occurs set component state
          // to display popup containing server/error response
          if (!errorRespObj && resp.dataset_id) {
            this.props.fetchDatasets();
            window.location = '#/datasets';
            this.setState({uploadButtonDisabled:false});
          } else {
            this.showErrorModal("Error Uploading Data", errorRespObj.errorResp.error || "Something went wrong");
            this.setState({uploadButtonDisabled:false});
          }
        });
      }


    } else {
      window.console.log('no file available');
      this.showErrorModal("File Update Error",'No file available');
      this.setState({
        uploadButtonDisabled:false
      });
    }

  }

  /** 
   * For the currently-loaded data, get the unique values for the given feature name.
   * @param {string} feature - feature name
   * @returns {array} - array of unique values for the feature. Order is taken from row order in data.
   */
  getUniqueValuesForFeature(feature) {
    let dataPrev = this.state.datasetPreview;
    //Read the column of data for the feature and make a unique set
    let values = [];
    dataPrev.data.map( (row) => {
      //NOTE - empircally, at the end we get an extra row with a single member set to "".
      //So skip if row[field] is undefined or ""
      if(row[feature] !== "" && row[feature] !== undefined) 
        values.push( row[feature] );
    })
    return [...new Set(values)];
  } 

  /** 
   * Check if the passed feature name exists in the data set
   * @returns {boolean} - true if yes, false otherwise
   */
  validateFeatureName(feature) {
    return feature !== undefined && this.getFeatureIndex(feature) >= 0;
  }

  /**
   * For the passed feature name, return its type
   * @param {string} feature 
   * @returns {string} feature type (as returned by one of gettors: featureTypeOrdinal, ...Categorical, ...Numeric, ...Dependent)
   */
  getFeatureType(feature) {
    let i = this.getFeatureIndex(feature);
    if( i === -1 ) {
      console.log("ERROR: unrecognized feature: " + feature);
      return this.featureTypeDefault;
    }
    return this.state.featureType[i];
  }

  /** For the passed feature name, return the index of the feature within the data (ie its column number).
   *  0-based
   *  Returns -1 for not found
   */
  getFeatureIndex(feature) {
    return this.state.datasetPreview.meta.fields.indexOf(feature.trim());
  }

  /**
   * Populate the state variable holding each feature's auto-determined default type.
   * Simple algorithm: if any value in the feature is type string, consider it 
   *  Categorical. Otherwise it's Numeric
   * We populate the state variable only once for each dataset so that in the case
   *  of very large datasets, we don't get bogged down each time a default type is
   *  needed.
   * @returns {null} 
   */
  initFeatureTypeDefaults() {
    if(this.state.datasetPreview == null) {
      console.log('ERROR - FileUpload.initFeatureTypeDefaults: datasetPreview is null');
      return;
    }
    let newDefaults = {};
    //First init all to type Numeric
    this.state.datasetPreview.meta.fields.forEach( (feature) => {
      newDefaults[feature] = this.featureTypeNumeric;
    })
    //Go through all values, if any are non-numeric, mark the field as type categorical
    this.state.datasetPreview.data.forEach( (row) => {
      this.state.datasetPreview.meta.fields.forEach( (feature) => {
        //NOTE - empircally, at the end we get an extra row with a single member set to "".
        //So skip if row[field] is undefined or ""
        if(isNaN(row[feature]) && row[feature] !== "" && row[feature] !== undefined) {
          newDefaults[feature] = this.featureTypeCategorical;
        }
      })
    })
    this.setState({ featureTypeDefaults: newDefaults });
  }

  /**
   * Initialize the dependent feature and set UI.
   * Looks for columns with particular headers, and if none found,
   * use the last column as dependent.
   * Make sure this gets called before the first call to setAllFeatureTypes, but
   * only gets called during init so user can override via UI.
   */
  initDependentColumn() {
    if(this.state.datasetPreview == null) {
      console.log('ERROR - FileUpload.initDependentColumn: datasetPreview is null');
      return;
    }
    let fields = this.state.datasetPreview.meta.fields;
    for( let i=0; i < fields.length; i++) {
      let feature = this.state.datasetPreview.meta.fields[i];
      if(feature.toLowerCase() === 'class' || feature.toLowerCase() === 'target' || i === (fields.length-1)){
        this.setFeatureType(feature, this.featureTypeDependent);       
        break;
      }
    }
  }

  /**
   * For the passed feature, get the default type for it based on automatic
   * feature-type assignment algorithm.
   * @param {string} feature 
   * @returns {string} If feature does not exist in data, return Numeric and print error to console
   */
  getFeatureDefaultType(feature) {
    if( !this.validateFeatureName(feature)) {
      console.log("Cannot get default type for unrecognized feature: " + feature);
      return this.featureTypeDefault;
    }
    return this.state.featureTypeDefaults[feature];
  }

  /**
   * Set the feature type for all features in the data.
   * Does NOT change type of column/feature that is assigned as dependent column.
   * Does NOT change features with any non-numeric values to type numeric. They are left unchanged.
   * @param {string} type - one of either [featureTypeNumeric, featureTypeCategorical, featureTypeOrdinal, 'autoDefault'],
   *  or 'autoDefault' which will set each feature type based on analysis of each feature's values
   */
  setAllFeatureTypes(type) {
    if(this.state.datasetPreview == null) {
      console.log('ERROR - FileUpload.setAllFeatureTypes: datasetPreview is null');
      return;
    }
    //Batch the setState calls that happen in setFeatureType so they don't re-render each time.
    //Some discussion here: https://medium.com/swlh/react-state-batch-update-b1b61bd28cd2
    //setFeatureType calls setState() each time it's called, and this triggers a re-render
    // of the component when not called from a react event handler or lifecycle method.
    // For larger files, this can end up taking a long time.
    ReactDOM.unstable_batchedUpdates(() => {
      this.state.datasetPreview.meta.fields.forEach( (feature, index) => {
        if( this.getFeatureType(feature) !== this.featureTypeDependent ) {
          let newType = type === 'autoDefault' ? this.getFeatureDefaultType(feature) : type;
          this.setFeatureType(feature, newType);  
        }
      })
    });
  }

  /** 
   * Set the feature-type for the specified feature. Implicitly updates feature-type dropdowns.
   * Does NOT allow setting feature to type Numeric for features that have default type Categorical.
   *   For these, it will ignore feature type Numeric.
   * Allows only one feature at a time to be type 'dependent'. 
   * Updates state vars that hold textural value of feature specifications for categorical and ordinal. 
   * @param {string} feature - feature name to update
   * @param {string} type - the new feature type for the feature (use of of the predefined featureType* accessors)
   * @param {array} ordinalValues - OPTIONAL array of strings, holding unique values for the feature. May be ranked or not.
   *                               If undefined, unique values are pulled from the data, without any particular ranking.
   * @returns {null}
  */
  setFeatureType(feature, type, ordinalValues) {
    if( type !== this.featureTypeNumeric &&
        type !== this.featureTypeCategorical &&
        type !== this.featureTypeOrdinal &&
        type !== this.featureTypeDependent) {
      console.log("ERROR: unrecognized feature type: " + type);
      return;
    }
    if(!this.validateFeatureName(feature)) {
      console.log("ERROR: setFeatureType: invalid feature type " + feature);
      return;
    }

    // Do not set to type Numeric if default type is non-numeric
    if( type === this.featureTypeNumeric && this.getFeatureDefaultType(feature) !== this.featureTypeNumeric) {
      //debug output in dev build
      if (this.isDevBuild) {
        console.log("setFeatureType: tried to set feature " + feature + " to type Numeric but it is not type Numeric by default.");
      }
      return;
    }
  
    // Handle setting dependent column type
    if( type == this.featureTypeDependent) {
        //Clear the currently-assigned dependent column if there is one
        this.clearDependentFeature();
    }
    
    // Handle ordinal type
    let ords = this.state.ordinalFeaturesObject;
    let ordsPrev = this.state.ordinalFeaturesObjectPrev;
    if( type === this.featureTypeOrdinal ) {
      //If we've passed in a list of values, use that. Otherwise if there's a stored list, use that,
      // otherwise pull list from the data.
      let values = ordinalValues !== undefined ? ordinalValues :
                  (ordsPrev[feature] !== undefined ? ordsPrev[feature] : this.getUniqueValuesForFeature(feature));
      ords[feature] = values;
      ordsPrev[feature] = values;
    }
    else {
      //Clear the ordinal list in case we had one from before.
      //But not the 'Prev' copy, in case user wants to restore.
      delete ords[feature];
    }

    // Store the type in the indexed-array
    let ftd = this.state.featureType;
    ftd[this.getFeatureIndex(feature)] = type;

    //Update state, including user text vars
    this.setState({
      featureType: ftd,
      ordinalFeaturesObject: ords,
      ordinalFeaturesObjectPrev: ordsPrev,
      ordinalFeaturesUserText: this.ordinalFeaturesObjectToUserText(),
      //NOTE - this also makes sure the string is updated properly for times when
      // user supplies a text string to specify categorical features, but has left
      // out one or more features that auto-default to type categorical.
      catFeaturesUserText: this.getCatFeatures().join()
    });
  }

  /** Handler for dropdowns show in Dataset Preview for specifying feature type */
  handleFeatureTypeDropdown = (e, data) => {
    //console.log(data);
    let feature = this.state.datasetPreview.meta.fields[data.customindexid];
    this.setFeatureType(feature, data.value);
  }

  /**
   * Handles button click to initiate ranking of an ordinal feature
   */
  handleOrdinalRankClick = (e, data) => {
    //console.log('Rank click')
    //Set this state var to track which field we're currently ranking.
    //Workaround for fact that I can't figure out how to get custom data into
    // the handleOrdinalSortDragRelease handler for sortable list
    this.setState( {
      ordinalFeatureToRank: data.customfeaturetorank,
      ordinalFeatureToRankValues: this.state.ordinalFeaturesObject[data.customfeaturetorank]
    })
  }

  /**
   * Handle event from sortable list, when user releaes an item after dragging it.
   * @param {Object} d 
   */
  handleOrdinalSortDragRelease (d) {
    if (this.state.ordinalFeatureToRank === undefined){
      console.log('Error: ordinal feature to rank is undefined')
      return;
    }
    let values = arrayMove(this.state.ordinalFeatureToRankValues, d.oldIndex, d.newIndex);
    this.setState({ordinalFeatureToRankValues: values});
  }

  /** Update state with the newly-ranked ordinal feature */
  handleOrdinalSortAccept() {
    let ordsAll = this.state.ordinalFeaturesObject;
    let ordsPrevAll = this.state.ordinalFeaturesObjectPrev;
    //For the feature the user has ranked, update the state to hold the newly ranked values
    ordsAll[this.state.ordinalFeatureToRank] = this.state.ordinalFeatureToRankValues;
    ordsPrevAll[this.state.ordinalFeatureToRank] = this.state.ordinalFeatureToRankValues;
    //Store newly ordered values in state, and clear vars used to show values for ranking.
    this.setState({
      ordinalFeaturesObject: ordsAll,
      ordinalFeaturesObjectPrev: ordsPrevAll,
      ordinalFeatureToRank: undefined,
      ordinalFeatureToRankValues: [],
      ordinalFeaturesUserText: this.ordinalFeaturesObjectToUserText()
    });
  }

  /** Handle user canceling the ordinal sort/ranking and modal text-input */
  handleOrdinalRankCancel() {
    this.setState({
      ordinalFeatureToRank: undefined,
      ordinalFeatureToRankValues: []
    })
  }

  /** Clear any features that have been specified as type ordinal, along with any related data,
   * and set them to type auto-determined default type.
   * @param {boolean} clearPrev - false by default, to NOT clear the storage of previous ordinal features, 
   * so you can still recover previous settings even when changing from user text input. 'True' will
   * clear the previous values (for testing).
  */
  ordinalFeaturesClearToDefault( clearPrev = false) {
    for(var feature in this.state.ordinalFeaturesObject) {
      this.setFeatureType(feature, this.getFeatureDefaultType(feature));
    }
    this.setState({
      ordinalFeaturesObject: {},
    })
    if(clearPrev) {
      this.setState({
        ordinalFeaturesObjectPrev: {},
      })
    }
  }

  /** From state, convert the lists of unique values for ordinal features into a string with
   * the ordinal feature name and its values, one per line.
   * @returns {string} - multi-line string with one ordinal feature and its unique values, comma-separated, per line
  */
  ordinalFeaturesObjectToUserText() {
    let result = "";
    for(var feature in this.state.ordinalFeaturesObject) {
      let values = this.state.ordinalFeaturesObject[feature];
      result += feature + ',' + values.join() + '\n';
    }
    return result;
  }

  /** Parse a single line of user text for specifying ordinal features. 
   *  Expects a comma-separated string of 2 or more field, with format 
   *    <feature name string>,<unique value 1>,<unique value 2>,...
   *  Leading and trailing whitespace is removed on the whole line and for each comma-separated item
   * Does not do any validation
   * @param {string} line - single line of user text for ordinal feature specification
   * @returns {object} - {feature: <feature name string>, values: <string array of unique values>}
  */
  ordinalFeaturesUserTextParse(line) {
    let feature = line.split(",")[0].trim();
    let values = line.split(",").slice(1);
    //Remove leading and trailing white space from each element
    values = values.map(function (el) {
      return el.trim();
    });
    return {feature: feature, values: values}
  }

  /** Take a SINGLE-line string for a SINGLE feature, of the format used in the UI box for a user to specify an ordinal feature and  
   *  the order of its unique values, and check whether it's valid. The contained feature name must exist and the specifed
   *  unqiue values must all exactly match (regardless of order) the unqiue values for the feature in the data.
   * @param {string} string - the string holding the user's specification 
   * @returns {object} - {success:[true|false], message: <relevant error message on failure>
   */
  ordinalFeatureUserTextLineValidate(string) {
    if( string.length === 0 ) {
      return {success: true, message: ""}
    }
    //Parse the line
    let ordObj = this.ordinalFeaturesUserTextParse(string);
    //Make sure feature name is valid
    if( !this.validateFeatureName(ordObj.feature) ) {
      return {success: false, message: "Feature '" + ordObj.feature + "' was not found in the data."}
    }
    //Make sure the feature name is not assigned as the dependent column
    if( this.getDependentColumn() === ordObj.feature ) {
      return {success: false, message: "Feature '" + ordObj.feature + "' is currently assigned as the Target Column."};
    }
    //The remaining items are the unique values
    if( ordObj.values === undefined || ordObj.values.length === 0) {
      return {success: false, message: "Feature '" + ordObj.feature + "' - no values specified"}
    }
    //Make sure the passed list of unique values matches the unique values from data,
    // ignoring order
    let dataValues = this.getUniqueValuesForFeature(ordObj.feature);
    if( dataValues.sort().join() !== ordObj.values.sort().join()) {
      return {success: false, message: "Feature '" + ordObj.feature + "': categories do not match (regardless of order) the unique values in the data: " + dataValues + "."}
    }
    //Otherwise we're good!
    return {success: true, message: ""}
  }

  /** Validate the whole text input for specify ordinal features 
   * Uses the current state var holding the ordinal features user text.
   * @returns {object} - {success: [true|false], message: <error message>}
  */
  ordinalFeaturesUserTextValidate() {
    //Return true if empty
    if(this.state.ordinalFeaturesUserText === ""){
      return {success: true, message: ""}
    }
    let success = true;
    let message = "";
    //Check each line individually
    this.state.ordinalFeaturesUserText.split(/\r?\n/).map((line) => {
      if(line === "")
        return;
      let result = this.ordinalFeatureUserTextLineValidate(line);
      if(result.success === false){
        success = false;
        message += result.message + "\n";
      }
    })
    return {success: success, message: message}
  }

  /** Process the current ordinal feature user text state variable to create
   *  relevant state data variables.
   *  Overrides any existing values in ordinalFeaturesObject
   *  Operates only on state variables.
   *  Does NOT perform any validation on the user text
   * @returns {null} 
   */
  ordinalFeaturesUserTextIngest() {
    // Get the lines before clearing ordinal features to default. Otherwise can
    // end up clearing ordinalFeaturesUserText in some cases.
    let lines = this.state.ordinalFeaturesUserText.split(/\r?\n/);
    this.ordinalFeaturesClearToDefault();
    //Process each line individually
    lines.map((line) => {
      if(line != "") {
        let ordObj = this.ordinalFeaturesUserTextParse(line);
        this.setFeatureType(ordObj.feature, this.featureTypeOrdinal, ordObj.values);       
      }
    })    
    //console.log("ingest: ordinals: ");
    //console.log(this.state.ordinalFeaturesObject);
  }

  /** Helper method to generate a segment with a button that opens
   *  Sortable List popups for ordering an ordinal feature.
   *  @param {string} feature the feature to generate a button for.
   *  @retuns {JSX} Return JSX with button for field type Ordinal, otherwise null for no button.
   */
  getDataTableOrdinalRankButton(feature) {
    //If it's ordinal add a button for user to define rank of values within the feature,
    // but only if we're not ranking another ordinal feature
    if(this.state.ordinalFeaturesObject[feature] !== undefined && 
      this.state.ordinalFeatureToRank === undefined) {
        return (
          <Segment>
            <Button
              content={"Rank"}
              inverted
              color="blue"
              compact
              size="small"
              customfeaturetorank={feature}
              onClick={this.handleOrdinalRankClick}
            />
          </Segment>                  
        )
      }

    //Otherwise just return null for no segment
    return null;
  }

  /**
   * Helper method to get all cells for the data table preview header row.
   * We put multiple items stacked into each header cell because we want
   * the header row to stay fixed as it scrolls, but we've been unable
   * to get multiple table rows to stay fixed.
   * @returns a JSX Table.HeaderCell 
   */
  getHeaderRowCells() {

    let dataPrev = this.state.datasetPreview;
    //Options for the per-feature dropdown in dataset preview
    const featureTypeOptionsAll = [
      { key: 1, text: 'Numeric', value: this.featureTypeNumeric},
      { key: 2, text: 'Categorical', value: this.featureTypeCategorical },
      { key: 3, text: 'Ordinal', value: this.featureTypeOrdinal },
    ]
    const featureTypeOptionsNonNumeric = [
      { key: 2, text: 'Categorical', value: this.featureTypeCategorical },
      { key: 3, text: 'Ordinal', value: this.featureTypeOrdinal },
    ]

    return (
      dataPrev.meta.fields.map((field, i) => {
          //Assign dropdown items for setting field type, or just 'Target' label for columns that's designated as target
          let fieldTypeItem = ( field === this.getDependentColumn() ?
            <i id={"featureTypeTargetLabel-"+i.toString()}>Target</i>
            :
            <Dropdown
              id={'featureTypeDropdown-' + i.toString()}
              value={this.state.featureType[i]}
              options={this.getFeatureDefaultType(field) === this.featureTypeNumeric ? featureTypeOptionsAll : featureTypeOptionsNonNumeric}
              onChange={this.handleFeatureTypeDropdown}
              customindexid={i}
            />
          )
          return (
            <Table.HeaderCell key={field} verticalAlign='top'>
              <Segment.Group compact>
                <Segment id={"table_header_label_" + field}> {field} </Segment>
                <Segment inverted> {fieldTypeItem} </Segment>
                {/*Return a segment with 'rank'button, or null, based on field type*/}
                {this.getDataTableOrdinalRankButton(field)}
              </Segment.Group>
            </Table.HeaderCell>
          )  
      })  
    )
  }

  /**
   * Helper method to create table for dataset preview upon selecting csv file.
   * Copied from Dataset component - relies upon javascript library papaparse to
   * partially read selected file and semantic ui to generate preview content,
   * if no preview available return hidden paragraph, otherwise return table
   * @returns {html} - html to display
   */
  getDataTablePreview() {
    let dataPrev = this.state.datasetPreview;
    let dataPrevTable = ( <p style={{display: 'none'}}> hi </p> );
    let innerContent;

    if(dataPrev && dataPrev.data) {
      //Show at most 50 rows
      innerContent = dataPrev.data.slice(0, 50).map((row, i) => {
        //Empirically, there's an extra row with a single empty field. Don't know why.
        if(Object.keys(row).length === 1 && Object.values(row)[0] === "")
          return;
        return (
          <Table.Row key={i}>
            <Table.Cell key={'dataTablePrevRow_'+i}>{i+1}</Table.Cell>
            {dataPrev.meta.fields.map(field => {
                let key_id = 'data_table_prev_' + i.toString() +'_' + field;
                return (
                  <Table.Cell key={key_id} id={key_id}>
                    {row[field]}
                  </Table.Cell>
                )
              }
            )}
          </Table.Row>
        )
      });

      dataPrevTable = (
        <div>
          <br/>
          <Header as='h2' inverted color='grey' style={{ display: 'inline', marginRight: '0.1em' }}> Dataset preview </Header>
          <span className="muted">{`First 50 rows max`}</span>
          <div style={{ overflowY: 'auto', maxHeight: '350px' }} className='table-sticky-header file-upload-table'>
            <Table inverted celled compact unstackable singleLine>
              <Table.Header>
                <Table.Row>
                  <Table.HeaderCell>{'Row'}</Table.HeaderCell>
                  {this.getHeaderRowCells()} 
                </Table.Row>
              </Table.Header>
              <Table.Body>
                {innerContent}
              </Table.Body>
            </Table>
          </div>
          <br/>
        </div>
      )
    }

    return dataPrevTable;
  }


  /** Return the string name of the user-specified dependent column.
   *  It's stored as a 'feature type' of 'dependent' for interoperability
   *  with the rest of the code.
   *  @returns {string} - Column/feature name. undefined if not set.
   */
  getDependentColumn() {
    if(this.state.datasetPreview == null)
      return undefined;
    let result = undefined;
    this.state.datasetPreview.meta.fields.forEach( (feature) => {
      if(this.getFeatureType(feature) === this.featureTypeDependent)
        result = feature;
    })
    return result;
  }

  /** Clear the depedent feature selection and return it to
   *  its default type.
   */
  clearDependentFeature() {
    let currentDep = this.getDependentColumn();
    currentDep !== undefined && this.setFeatureType(currentDep, this.getFeatureDefaultType(currentDep));
  }

  /**
   * Small helper to get an array of features that have been assigned
   * to type 'categorical'
   * @returns {array} - array of strings
   */
  getCatFeatures(){
    let dataPrev = this.state.datasetPreview;
    if(!dataPrev)
      return [];
    return dataPrev.meta.fields.filter( (field,i) => {
      return this.state.featureType[i] == this.featureTypeCategorical;
    })
  }

  /**
   * or a two hyphen-separated features denoting a range such as 'weight-height'.
   * The range is constructed using the indicies of the two feature names within the data fields.
   * @param {string} featureToken - either a solitary feature name, or a hyphen-separated two-feature range.
   * @returns {object} {success:[true|false], rangeExpanded:<array>} - on success, rangeExpanded is an array of all features names
   * within the range specified by input token. Fails if there are not two valid features in the token, or if they're out of index order.
   */
  parseFeatureToken(featureToken) {
    let features = featureToken.trim().split("-");
    //Make sure
    // the range has two features
    // features names are valid
    // the 2nd feature comes after the first in the data
    if( features.length != 2 ||
        !this.validateFeatureName(features[0]) ||
        !this.validateFeatureName(features[1]) ||
        this.getFeatureIndex(features[1]) < this.getFeatureIndex(features[0])
      ){
      return {success: false, rangeExpanded: ""};
    }
    let rangeExpanded = this.state.datasetPreview.meta.fields.slice(this.getFeatureIndex(features[0]), this.getFeatureIndex(features[1])+1 );    
    return {success: true, rangeExpanded: rangeExpanded}
  }

  /** 
   * Validate, and possibly expand, the passed string holding text input from user for specifying categorical-type feature.
   *  Validates that each token in the string is a valid feature name in the data,
   *  or is a valid feature-name range from the data.
   *  Expands any feature-name ranges in the string into a comman-separated string of single feature names
   *  and inserts them into the complete result.
   *  
   * @returns {object} - {success:<boolean>, // True if valid, False otherwise 
   *                      message:<string>   // error message on failure
   *                      expanded:<string>  // String holding fully-expanded list of categorical features
   */
  catFeaturesUserTextValidateAndExpand(userText) {
    if(userText.trim() === "") {
      return {success: true, message: "", expanded: ""}
    }
    let success = true;
    let message = "Invalid features or feature ranges ";
    let expanded= [];
    userText.split(",").forEach( (feature) => {
      if( !this.validateFeatureName(feature.trim())) {
        //Check if it's specifying a range
        let range = this.parseFeatureToken(feature);
        if( !range.success ) {
          success = false;
          message += ", " + feature;  
        } else {
          //Returns an array, so concatenate to create a single array instead of array of array
          expanded = expanded.concat(range.rangeExpanded);
        }
      } else {
        //It's a single feature, so just add it to the list
        expanded.push(feature);
      }
    })
    //Check that user isn't including the currently-defined dependent column
    if( success ) {
      let depCol = this.getDependentColumn();
      if( depCol !== undefined && expanded.indexOf(depCol) > -1 ) {
        success = false;
        message = "The feature " + depCol + " cannot be used because it is assigned as the Dependent Column.";
      }
    }

    return {success: success, message: message, expanded: expanded.join()}
  }

  /** Create UI for some data set options */
  getUserDatasetOptions() {
    //Options for the dependent column selection dropdown
    const depColOptions = [];
    if( this.state.datasetPreview) {
      let features = this.state.datasetPreview.meta.fields;
      features.map( (value, index) => {
        depColOptions.push( { key: index, text: value, value: value })
      })  
    }

    //Options for the prediction-type dropdown
    const predictionOptions = [
      {
        key: "classification",
        text: "classification",
        value: "classification"
      },
      {
        key: "regression",
        text: "regression",
        value: "regression"
      },
    ]

    // var [eventsEnabled, setEventsEnabled] = React.useState(true)
    // var [open, setOpen] = React.useState(true)
    // var [aa, bb] = React.useState(true)
    // var [ed, cc] = React.useState(true)

    // const [count, setCount] = React.useStat/e(0);

    return (
        
        <Grid columns={4} >
        <Grid.Row>
          <Grid.Column width={6}>
 
            <Form.Field 
              id="target_dropdown"
              inline
              label="Target"
              control={Dropdown}
              search
              fluid
              placeholder="Select a column"
              options={depColOptions}
              onChange={this.handleDepColDropdown}
              className="inverted-dropdown-search"
              defaultValue={this.getDependentColumn()}
            />
              
              
          </Grid.Column>
          <Grid.Column width={2} style={{marginTop: '1.9em', paddingLeft: '0'}}>
            <Popup
              on="click"
              // visibility={this.state.showDepColHelp ? 'visible' : 'hidden'}
              // open={this.state.showDepColHelp}

              id="theIdHere"
              // open
              header="Target Column Help"
              position="right center"
              content={
                <div className="content">
                  <p> {this.depColHelpText} </p>
                </div>
              }
              trigger={
                <Icon
                  inverted
                  size="large"
                  color="blue"
                  name="info circle"
                  className="file-upload-help-icon"
                  />
              }
            />
          </Grid.Column>
          <Grid.Column width={6}>
            <Form.Field
              id="prediction_type_dropdown" 
              inline
              label="Prediction Type"
              control={Dropdown} 
              defaultValue={this.defaultPredictionType}
              options={predictionOptions}
              onChange = {this.handlePredictionType}
              fluid
              className="inverted-dropdown-inline"
            />
          </Grid.Column>
          <Grid.Column width={2} style={{marginTop: '1.9em', paddingLeft: '0'}}>
            <Popup
              on="click"
              position="left center"
              header="Prediction Type Help"
              content={
                <div className="content">
                    {this.predictionTypeHelp}
                </div>
              }
              trigger={
                <Icon
                  inverted
                  size="large"
                  color="blue"
                  name="info circle"
                  className="file-upload-help-icon"
                />
              }
            />
          </Grid.Column>
        </Grid.Row>
        </Grid>
        

    )
  }

  /** Create the UI for users to enter feature types manually */
  getUserFeatureTypeControls() {

    let itemContent=(
      <React.Fragment>
        {'Numeric / Categorical'}
        <div>(auto-detect)</div>
      </React.Fragment>
    )

    let content = (
      //---- Ordinal Feature Text Input ----
      <div>
      <Grid columns={3}>
        <Grid.Row>
        <Grid.Column>
          <Form.Input>
            <Button
              id="ord_features_text_input_open_button"
              color='blue'
              size='small'
              fluid
              inverted
              disabled={this.state.ordinalFeatureToRank !== undefined}
              className="file-upload-button"
              content="Set Ordinal"
              onClick={() => this.setState({ordinalFeaturesUserTextModalOpen: !this.ordinalFeaturesUserTextModalOpen})}
            />
            <Popup
              on="click"
              position="right center"
              header="Ordinal Features Help"
              content={
                <div className="content">
                {this.ordFeatHelpText}
                </div>
              }
              trigger={
                <Icon
                  inverted
                  size="large"
                  color="blue"
                  name="info circle"
                />
              }
            />
          </Form.Input>
        </Grid.Column>
        {/*---- Categorical Feature Text Input ----*/}
        <Grid.Column>
          <Form.Input>
            <Button
              id="cat_features_text_input_open_button"
              color='blue'
              size='small'
              fluid
              inverted
              disabled={this.state.ordinalFeatureToRank !== undefined}
              className="file-upload-button"
              content="Set Categorical"
              onClick={() => this.setState({catFeaturesUserTextModalOpen: true})}
              />
            <Popup
              on="click"
              position="right center"
              header="Categorical Features Help"
              content={
                <div className="content">
                {this.catFeatHelpText}
                </div>
              }
              trigger={
                <Icon
                  inverted
                  size="large"
                  color="blue"
                  name="info circle"
                />
              }
            />
          </Form.Input>
        </Grid.Column>
        <Grid.Column>
          <Form.Input>
            <Button
              id='set_all_to_button'
              color='blue'
              size='small'
              fluid
              inverted
              content="Set All To..."
              className="file-upload-button"
              onClick={() => this.setState({allFeaturesMenuOpen: !this.state.allFeaturesMenuOpen})}
            />
            {/*dropdown menu*/}
            <div style={{ display: this.state.allFeaturesMenuOpen ? "block" : "none" }}>
              <Menu vertical open={this.state.allFeaturesMenuOpen} id='set_all_to_menu'>
                <Menu.Item 
                  id='set_all_to_menu_categorical'
                  content={'Categorical'}
                  onClick={() => {this.setAllFeatureTypes(this.featureTypeCategorical); this.setState({allFeaturesMenuOpen: false}) }}
                />
                <Menu.Item 
                  id='set_all_to_menu_ordinal'
                  content={'Ordinal'}
                  onClick={() => {this.setAllFeatureTypes(this.featureTypeOrdinal); this.setState({allFeaturesMenuOpen: false}) }}
                />
                <Menu.Item 
                  id='set_all_to_menu_default'
                  content={
                    <React.Fragment>
                      {'Numeric / Categorical'}
                      <div>(auto-detect)</div>
                    </React.Fragment>
                  }
                  onClick={() => {this.setAllFeatureTypes('autoDefault'); this.setState({allFeaturesMenuOpen: false}) }}
                />
              </Menu>
            </div>
          </Form.Input>
        </Grid.Column>
        </Grid.Row>
      </Grid>
      </div>
    )
    return content;
  }

  /** Return the UI for ranking ordinal features via drag-and-drop 
   *  NOTE there was a lot of trouble getting styling of this sortable list to work
   *  properly in the Semantic UI Modal element, so do it just this simple way as
   * a pseudo-modal dialog.
  */
  getOridinalRankingDialog() {
      //Helper method for sortable list component
      // https://github.com/clauderic/react-sortable-hoc
      // https://clauderic.github.io/react-sortable-hoc/#/basic-configuration/multiple-lists?_k=7ghtqv
      const SortableItem = SortableElement(({value}) => <li className={"file-upload-sortable-list-item"}>{value}</li>);
      //Helper method for sortable list component
      const SortableList = SortableContainer(({items}) => {
        return (
          <ul className={"file-upload-sortable-list"}>
            {items.map((value, index) => (
              <SortableItem key={`item-${value}`} index={index} value={value} />
            ))}
          </ul>
        );
      });

    return (
      <div className="file-upload-centered-div">
        <Segment raised compact>
          <SceneHeader header="Rank the Feature Values"/>
          <Segment raised style={{overflow: 'auto', maxHeight: '50vh' }}>
            <SortableList helperClass='file-upload-sortable-list-item-helper' items={this.state.ordinalFeatureToRankValues} onSortEnd={this.handleOrdinalSortDragRelease} />
          </Segment>
          <Button
            className='file-upload-pseudo-dialog-button'
            content={"Accept"}
            inverted
            color="blue"
            onClick={this.handleOrdinalSortAccept}
          />
          <Button
            className='file-upload-pseudo-dialog-button'
            content={"Cancel"}
            inverted
            color="red"
            onClick={this.handleOrdinalRankCancel}
          />
        </Segment>
      </div>
    )
  }

  /** Return a pseudo-modal UI for specifying categorical features via text input.
   * NOTE couldn't get semantic ui react's Modal option to do the 'inverted' property,
   * or to change colors based on styles, so am doing it this way with a simple div that
   * replaces everything else while it's active. 
   */
  getCatFeaturesUserTextModal() {
    //First determine whether there's a user-supplied string of cat features to show that
    // may contain feature ranges.
    let catFeaturesUserTextToDisplay = this.state.catFeaturesUserText;
    if( this.state.datasetPreview ) {
      let res = this.catFeaturesUserTextValidateAndExpand(this.state.catFeaturesUserTextRaw);
      if( res.success ) {
        // If the current fully expanded string equals the expanded verison of the raw string,
        // show the raw string since it may contain feature ranges.
        if( this.state.catFeaturesUserText.split(",").sort().join() === res.expanded.split(",").sort().join() ){
          catFeaturesUserTextToDisplay = this.state.catFeaturesUserTextRaw;
        }
      }  
    }

    return(
      //--
      // NOTE the component layout and classNames used here are the same as for getOrdinalFeaturesUserTextModal,
      // but that one renders with a nice width-limited top-segment, while this one renders and stretches to fill
      // window width. I can't figure out why.
      //--
      <div className="file-upload-centered-div">
        <Segment raised compact >
          <SceneHeader header="Categorical Feature Specification"/>
          <Segment className="file-upload-feature-text-info">
            <p>Enter a comma-separated list to specify which features are Categorical.<br/>
                This will override selections in the Dataset Preview. </p>
            <p>For example:<br/>
                &emsp;<i>sex,eye_color,hair_color,disease_state</i>
            </p>
            <p>Ranges - you can specify features using ranges. Each feature name in a range is converted to a column number within the data, 
              and the range is expanded using the column numbers. For example, working from the example above in which
              we assume the features are present in the data in the same order as listed, entering <br/>
              &emsp;<i>sex-disease_state</i><br/><br/>
              would expand to<br/>
              &emsp;<i>sex,eye_color,hair_color,disease_state</i>
            </p>
          </Segment>
          <Segment>
            <textarea
              id="categorical_features_text_area_input"
              className="file-upload-feature-text-input"
              label="Categorical Features"
              onChange={this.handleCatFeaturesUserTextOnChange}
              onBlur={this.handleCatFeaturesUserTextBlur}
              placeholder={this.getCatFeatures().length === 0 ? "(No Categorical features have been specified)" : "" }
              value={catFeaturesUserTextToDisplay}
              autoFocus
              rows={10}
            />
          </Segment>
          <Button
            id="cat_features_user_text_accept_button"
            className='file-upload-pseudo-dialog-button'
            content="Accept"
            icon='checkmark'
            onClick={this.handleCatFeaturesUserTextAccept}
            inverted
            color="blue"
          />
          <Button 
            id="cat_features_user_text_cancel_button"
            className='file-upload-pseudo-dialog-button'
            color='red' 
            onClick={this.handleCatFeaturesUserTextCancel}
            inverted
            content="Cancel"
          />
        </Segment>
      </div>
    )
  }

  /** Return a pseudo-modal UI for specifying ordinal features and values via text input.
   * NOTE couldn't get semantic ui react's Modal option to do the 'inverted' property,
   * or to change colors based on styles, so am doing it this way with a simple div that
   * replaces everything else while it's active. 
   */
  getOrdinalFeaturesUserTextModal() {
    return(
      <div className="file-upload-centered-div">
        <Segment raised compact>
          <SceneHeader header="Ordinal Feature Specification"/>
          <Segment className="file-upload-feature-text-info">
            <p> For each ordinal feature, enter one comma-separated line with the following format (this overrides selections in the Dataset Preview): <br/>
              &emsp;[feature name],[1st unique value],[2nd unique value],...</p>
            <p>For example:<br/>
              &emsp;month,jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec<br/>
              &emsp;day,mon,tue,wed,thu,fri,sat,sun</p>
            <p>To populate this text box with all features and their unique values, close this window and use the button to set all feature types as ordinal. </p>
            <br/>
          </Segment>
          <Segment>
            <textarea
              className="file-upload-feature-text-input"
              id="ordinal_features_text_area_input"
              label="Ordinal Features"
              onChange={this.handleOrdinalFeaturesUserTextOnChange}
              placeholder={this.ordinalFeaturesObjectToUserText().length === 0 ? "(No Ordinal features have been specified.)" : "" }
              value={this.state.ordinalFeaturesUserText}
              autoFocus
              rows={10}
            />
          </Segment>
          <Button
            id="ordinal_features_user_text_accept_button"
            className='file-upload-pseudo-dialog-button'
            content="Accept"
            icon='checkmark'
            onClick={this.handleOrdinalFeaturesUserTextAccept}
            color="blue"
            inverted
          />
          <Button
            id="ordinal_features_user_text_cancel_button" 
            className='file-upload-pseudo-dialog-button'
            color='red' 
            onClick={this.handleOrdinalFeaturesUserTextCancel}
            content="Cancel"
            inverted
          />
        </Segment>
      </div>
    )
  }

  handleErrorModalClose(){
    this.setState({
      showErrorModal: false,
      errorModalHeader: "",
      errorModalContent: ""
    });
    //Reenable document-wide keydown handling
    this.enableKeyDownHandler(true);
  }  

  /**
   * Show the blocking error message modal dialog.
   * If it's already showing, this will overwrite the contents.
   * @param {} header 
   * @param {*} content
   * @return {void} 
   */
  showErrorModal(header, content) {
    //Turn off document-wide key handling because they'll get handled
    // by this modal, but then also by document, which is not what we want.
    // If we leave this enabled at his esc to dismiss error dialog, the esc
    // keydown event is also caught by the document and closes the other
    // dialog that may be open under the error dialog. ugly.
    this.enableKeyDownHandler(false);
    this.setState({
      showErrorModal: true,
      errorModalHeader: header,
      errorModalContent: content
    });
  }



  render() {


    



    //const { dataset } = this.props;

    let errorContent;
    let dataPrevTable = this.getDataTablePreview();
    let userFeatureTypeControls = this.getUserFeatureTypeControls();
    let userDatasetOptions = this.getUserDatasetOptions();

    // default to hidden until a file is selected, then display input areas
    let formInputClass = "file-upload-form-hide-inputs";

    // check if file with filename has been selected, if so then use css to show form
    this.state.selectedFile && this.state.selectedFile.name ?
      formInputClass = "file-upload-form-show-inputs" : null;

    // file input
    // https://react-dropzone.js.org/
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#accept*
    let fileInputElem = undefined;


    
    // let selectedFileIcon =  undefined;
    

    function onDrop(acceptedFiles) {
      // const req = request.post('/upload')
      // acceptedFiles.forEach(file => {
      //   req.attach(file.name, file)
      // })
      // req.end(callback)
      this.handleUpload
    }
    

    // code for dragable icon
    // prevent each mydivs from being overlapped


    var styles = `

    #mydivs_home {

      content: "";
      display: table;
      clear: both;
      
    
    }

    #mydiv, #mydiv2, #mydiv3, #mydiv4, #mydiv5 {
      position: absolute;

      background-color: #fff0;
      border: 1px solid #fff0;;
      text-align: center;
  


      float: left;
  
      padding: 10px;

      



    }
    
    #mydivheader, #mydivheader2, #mydivheader3, #mydivheader4, #mydivheader5 {
      padding: 10px;
      cursor: move;

      background-color: #fff0;
      color: #fff0;
      float: left;
      display: inline-block;
    }
`

    

   
    
    // add the styles for dragable icon
    if(document.getElementsByTagName("style").length == 0)
    {

      var styleSheet = document.createElement("style")
      styleSheet.innerText = styles
      document.head.appendChild(styleSheet)
    }

    // Make the DIV element draggable:
    if (document.getElementById("mydiv")!=null){
        dragElement(document.getElementById("mydiv"));
        dragElement(document.getElementById("mydiv2"));
        dragElement(document.getElementById("mydiv3"));
        dragElement(document.getElementById("mydiv4"));
        dragElement(document.getElementById("mydiv5"));
        // dragElement(document.getElementById("preloaded_data_1"));
        // dragElement(document.getElementById("preloaded_data_2"));

    }
    
  function dragElement(elmnt) {
    var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    if (document.getElementById(elmnt.id + "header")) {
      // if present, the header is where you move the DIV from:
      document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
    } else {
      // otherwise, move the DIV from anywhere inside the DIV:
      elmnt.onmousedown = dragMouseDown;
    }

  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    // get the mouse cursor position at startup:
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    // call a function whenever the cursor moves:
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    // calculate the new cursor position:
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    // set the element's new position:
    elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
    elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
  }

  function closeDragElement() {
    // stop moving when mouse button is released:
    document.onmouseup = null;
    document.onmousemove = null;
  }
}

    // selectedFile
    // let selectedFile = this.state.selectedFile;
    // remove all file icons when one of files is clicked
    function clearFileIcons(currentFile) {
    
    // selectedFileIcon=currentFile
    // console.log(selectedFileIcon)
    
    // var selectedFileIconds=document.getElementById(currentFile)
    // selectedFileIconds.parentNode.removeChild(selectedFileIconds);

    // parse currentFile to get the number
    var currentFileNumber = currentFile.split("_")[2];
    console.log(currentFileNumber)

    var fileIcon = document.getElementById("preloaded_data_" + currentFileNumber);
    if (fileIcon) {
      fileIcon.parentNode.removeChild(fileIcon); 
    }

    // if ("preloaded_data_" + currentFileNumber)
    // {
    //   onDrop("iris.tsv")
    // }

    

    // console.log("clearing file icons");

    // // generate number from 1 to 5
    // for (var i = 1; i <= 5; i++) {
    //   console.log("removing file icon " + i);
    //   var fileIcon = document.getElementById("preloaded_data_" + i);
    //   if (fileIcon) {
    //     fileIcon.parentNode.removeChild(fileIcon); 
    //   }
    // }


    




    }

    // add checkmark icon t the selected file icon when one of files is clicked
    function checkonFileIcons(currentFile){
      // parse currentFile to get the number
      var currentFileNumber = currentFile.split("_")[2];
      console.log(currentFileNumber)

      // add checkmark icon to the selected file icon. The checkmark icon should be overlayed on the file icon

      
      var selectedFileIcon = document.getElementById("preloaded_data_" + currentFileNumber);
      selectedFileIcon.innerHTML = "<i class='checkmark icon'></i>";

        
    }

    function DropzoneWithoutClick(props) {
      const {getRootProps, acceptedFiles} = useDropzone();
      const files = acceptedFiles.map(file => <li key={file.path}>{file.path}</li>);
    
      return (
        <section className="container">
          <div {...getRootProps({className: 'dropzone'})}>
            <p>Dropzone without click events</p>
          </div>
          <aside>
            <h4>Files</h4>
            <ul>{files}</ul>
          </aside>
        </section>
      );
    }




    if( this.state.selectedFile == null ) {


      // function onDrop(acceptedFiles) {
      //   console.log(acceptedFiles);
      //   // this.setState({ selectedFile: acceptedFiles[0] });
      // }
     
      fileInputElem = (
        // make any file icon on web site work with dropzone

       
        <Dropzone
            id="file-dropzone"
            onDropAccepted={this.handleSelectedFile}
            onDropRejected={this.handleRejectedFile}
            
            // onDrop={onDrop}

            // mouse over the file icon, the file icon will be highlighted
            

            
            
            
            accept=".csv,.tsv,text/csv,text/tsv"
            multiple={false}
        >
          {({getRootProps, getInputProps}) => (
            <section>
              <div {...getRootProps({ className: "dropzone" })}>
                <input {...getInputProps()} />
                <p>Choose a csv or tsv file</p>
                <p>Drag 'n drop, or click here</p>
                {/* <p>Click one of preloaded datasets</p> */}
                
              </div>
            </section>
          )}
        </Dropzone>

        
        // <DropzoneWithoutClick></DropzoneWithoutClick>




        
        
      );
    } else {
      //Cancel button
      fileInputElem = (
        <React.Fragment>
          <Divider inverted horizontal>
            <Header inverted as='h4' className="file-upload-header">
              File
            </Header>
           </Divider>
          <Header inverted as='h5' style={{marginTop: '1em'}}>
            {this.state.selectedFile.name}
          </Header>
        </React.Fragment>
      )
    }
    
    // console.log("selectedFileIcon")
    // console.log(selectedFileIcon)
    // if first file icon is clicked 
    // if (selectedFileIcon != undefined)
    // {
    //   console.log("selectedFileIcon is not undefined")
    // }


    //Progress spinner if we're loading and processing a file
    //
    if( this.state.processingFileForPreview){
      return <Loader active inverted size="large" content="Processing your file..." />;      
    }

    //Modal for error messages
    //NOTE - check this BEFORE the pseudo-modal dialogs and other blocking
    // UI elements that get checked below before the main return statement.
    // This is outside the main return statement scope because of the use
    // of the pseudo-modal windows just below.

    if(this.state.showErrorModal){
      var errorModalContent = this.state.errorModalContent.split("*");

      return(
      <Modal style={{ marginTop:'0' }} open={this.state.showErrorModal} onClose={this.handleErrorModalClose} closeIcon id="error_modal_dialog"> 
        <Modal.Header>{this.state.errorModalHeader}</Modal.Header>

        <Modal.Content>{this.state.errorModalContent}</Modal.Content>


      </Modal>
      )
    }
  
    //Show just the ordinal feature ranking UI if user has clicked 'Rank' button.
    if(this.state.ordinalFeatureToRank !== undefined) {
      return this.getOridinalRankingDialog();
    }

    //Show pseudo-modal window for textual input of ordinal feature specifications.
    if(this.state.ordinalFeaturesUserTextModalOpen) {
      return this.getOrdinalFeaturesUserTextModal();
    }

    //Show pseudo-modal window for textual input of categorical feature specifications.
    if(this.state.catFeaturesUserTextModalOpen) {
      return this.getCatFeaturesUserTextModal();
    }


    // console.log(this.state.selectedFile);
    // console.log("file-upload-icon).length");
    // console.log(document.getElementsByClassName("file-upload-icon").length);

    if (this.state.selectedFile != null) {

      console.log("selected file is not null and I am removing file icons")
      // when a file is selected, remove all file icons
      // if there is a icon with id preloaded_data_1, then remove it
      if (document.getElementById("preloaded_data_1")) {
        console.log("preloaded_data_1 exists")
        clearFileIcons("preloaded_data_1");
        clearFileIcons("preloaded_data_2");
        clearFileIcons("preloaded_data_3");
        clearFileIcons("preloaded_data_4");
        clearFileIcons("preloaded_data_5");

        // remove mydiv id 
        var mydiv = document.getElementById("mydiv");
        var mydiv2 = document.getElementById("mydiv2");
        var mydiv3 = document.getElementById("mydiv3");
        var mydiv4 = document.getElementById("mydiv4");
        var mydiv5 = document.getElementById("mydiv5");

        if (mydiv != null && mydiv2 != null && mydiv3 != null && mydiv4 != null && mydiv5 != null) {
          mydiv.parentNode.removeChild(mydiv);
          mydiv2.parentNode.removeChild(mydiv2);
          mydiv3.parentNode.removeChild(mydiv3);
          mydiv4.parentNode.removeChild(mydiv4);
          mydiv5.parentNode.removeChild(mydiv5);
        }

      }

      // clearFileIcons("preloaded_data_1")
    }


    // when user did not upload file after clicking the upload button, then show the file icons
    else if (document.getElementsByClassName("file-upload-icon").length == 0 )
    {

      if (document.getElementsByClassName("file-upload-icon").length ==1)
      {
        document.body.removeChild(document.getElementsByClassName("file-upload-icon")[0]);
      }

      console.log("selected file is null")
      // create a div element className "file-upload-icon"
      var fileUploadIcons = document.createElement("div");
      fileUploadIcons.className = "file-upload-icon";
      // add this div element div app 
      // document.getElementById("app").appendChild(fileUploadIcons);


      // <i id = "preloaded_data_1" className="blue huge file icon" onClick = {() => clearFileIcons("preloaded_data_1")}></i>
      // create a i element className ="blue huge file icon"
      var fileIcon1 = document.createElement("i");
      fileIcon1.className = "blue huge file icon";
      fileIcon1.id = "preloaded_data_1";
      // fileIcon1.onclick = function () { clearFileIcons("preloaded_data_1") };
      // make upload the iris.tsv file when the file icon is clicked
      // fileIcon1.onclick = function () { uploadFile("iris.tsv") };
      // add this i element to the div element
      // fileUploadIcons.appendChild(fileIcon1);

      // <div id="mydiv">
              // <div id="mydivheader"></div>
      // create a div id with mydiv
      var mydiv = document.createElement("div");
      mydiv.id = "mydiv";
      // create a div id with mydivheader
      var mydivheader = document.createElement("div");
      mydivheader.id = "mydivheader";

      // add mydivheader to mydiv
      mydiv.appendChild(mydivheader);

      // add fileIcon1 to mydivheader
      mydivheader.appendChild(fileIcon1);

      // add mydiv to app
      // document.getElementById("app").appendChild(mydiv);
      // add to body
      // document.body.appendChild(mydiv);

      

      




      




      //  <i id = "preloaded_data_2" className="red huge file icon" onClick = {() => clearFileIcons("preloaded_data_2")}></i>
      // create a i element className ="red huge file icon"
      var fileIcon2 = document.createElement("i");
      fileIcon2.className = "red huge file icon";
      fileIcon2.id = "preloaded_data_2";
      // fileIcon2.onclick = function () { clearFileIcons("preloaded_data_2") };
      // add this i element to the div element
      // fileUploadIcons.appendChild(fileIcon2);

      var mydiv2 = document.createElement("div");
      mydiv2.id = "mydiv2";
      // create a div id with mydivheader
      var mydivheader2 = document.createElement("div");
      mydivheader2.id = "mydivheader2";

      // add mydivheader to mydiv
      mydiv2.appendChild(mydivheader2);

      // add fileIcon1 to mydivheader
      mydivheader2.appendChild(fileIcon2);

      // add mydiv to app
      // document.getElementById("app").appendChild(mydiv);
      // add to body
      // document.body.appendChild(mydiv2);







      //  <i id = "preloaded_data_3" className="green huge file icon" onClick = {() => clearFileIcons("preloaded_data_3")}></i>
      // create a i element className ="green huge file icon"
      var fileIcon3 = document.createElement("i");
      fileIcon3.className = "green huge file icon";
      fileIcon3.id = "preloaded_data_3";
      // fileIcon3.onclick = function () { clearFileIcons("preloaded_data_3") };
      // add this i element to the div element
      // fileUploadIcons.appendChild(fileIcon3);

      var mydiv3 = document.createElement("div");
      mydiv3.id = "mydiv3";
      // create a div id with mydivheader
      var mydivheader3 = document.createElement("div");
      mydivheader3.id = "mydivheader3";

      // add mydivheader to mydiv
      mydiv3.appendChild(mydivheader3);

      // add fileIcon1 to mydivheader
      mydivheader3.appendChild(fileIcon3);

      // add mydiv to app
      // document.getElementById("app").appendChild(mydiv);
      // add to body
      // document.body.appendChild(mydiv3);




      //  <i id = "preloaded_data_4" className="yellow huge file icon" onClick = {() => clearFileIcons("preloaded_data_4")}></i>
      // create a i element className ="yellow huge file icon"
      var fileIcon4 = document.createElement("i");
      fileIcon4.className = "yellow huge file icon";
      fileIcon4.id = "preloaded_data_4";
      // fileIcon4.onclick = function () { clearFileIcons("preloaded_data_4") };
      // add this i element to the div element
      // fileUploadIcons.appendChild(fileIcon4);

      var mydiv4 = document.createElement("div");
      mydiv4.id = "mydiv4";
      // create a div id with mydivheader
      var mydivheader4 = document.createElement("div");
      mydivheader4.id = "mydivheader4";

      // add mydivheader to mydiv
      mydiv4.appendChild(mydivheader4);

      // add fileIcon1 to mydivheader
      mydivheader4.appendChild(fileIcon4);

      // add mydiv to app
      // document.getElementById("app").appendChild(mydiv);
      // add to body
      // document.body.appendChild(mydiv4);


      //  <i id = "preloaded_data_5" className="purple huge file icon" onClick = {() => clearFileIcons("preloaded_data_5")}></i>
      // create a i element className ="purple huge file icon"
      var fileIcon5 = document.createElement("i");
      fileIcon5.className = "purple huge file icon";
      fileIcon5.id = "preloaded_data_5";
      // fileIcon5.onclick = function () { clearFileIcons("preloaded_data_5") };
      // add this i element to the div element
      // fileUploadIcons.appendChild(fileIcon5);

      var mydiv5 = document.createElement("div");
      mydiv5.id = "mydiv5";
      // create a div id with mydivheader
      var mydivheader5 = document.createElement("div");
      mydivheader5.id = "mydivheader5";

      // add mydivheader to mydiv
      mydiv5.appendChild(mydivheader5);

      // add fileIcon1 to mydivheader
      mydivheader5.appendChild(fileIcon5);

      // add mydiv to app
      // document.getElementById("app").appendChild(mydiv);
      // add to body
      // document.body.appendChild(mydiv5);







      // add fileUploadIcons to the body
      document.body.appendChild(fileUploadIcons);




      //make <div id = "iconshome" style="display: flex; justify-content: space-around"> if it does not exist
      if (document.getElementById("iconshome") == null) {
        // create a div element id = "iconshome"
        var iconshome = document.createElement("div");
        iconshome.id = "iconshome";
        // iconshome.style = "display: flex; justify-content: space-around";

        // iconshome.style = "display: table; width: 100%; table-layout: fixed; border-spacing: 10px;";
        iconshome.style = "display: table; width: 100%; border-spacing: 10px;";
        // add this div element div app
        document.body.appendChild(iconshome);

        // add mydiv to iconshome
        document.getElementById("iconshome").appendChild(mydiv);
        // locate mydiv with x and y coordinates
        mydiv.style.position = "absolute";
        mydiv.style.left = '28' + "px";
        mydiv.style.top = '340' + "px";
        // add mydiv2 to iconshome
        document.getElementById("iconshome").appendChild(mydiv2);
        // locate mydiv2 with x and y coordinates
        mydiv2.style.position = "absolute";
        mydiv2.style.left = '128' + "px";
        mydiv2.style.top = '340' + "px";

        // add mydiv3 to iconshome
        document.getElementById("iconshome").appendChild(mydiv3);
        // locate mydiv3 with x and y coordinates
        mydiv3.style.position = "absolute";
        mydiv3.style.left = '228' + "px";
        mydiv3.style.top = '340' + "px";
        // add mydiv4 to iconshome
        document.getElementById("iconshome").appendChild(mydiv4);
        // locate mydiv4 with x and y coordinates
        mydiv4.style.position = "absolute";
        mydiv4.style.left = '328' + "px";
        mydiv4.style.top = '340' + "px";
        // add mydiv5 to iconshome
        document.getElementById("iconshome").appendChild(mydiv5);
        // locate mydiv5 with x and y coordinates
        mydiv5.style.position = "absolute";
        mydiv5.style.left = '428' + "px";
        mydiv5.style.top = '340' + "px";
      }
      



      

    }

    // after cancel
    else if (document.getElementsByClassName("file-upload-icon").length == 100) {

      console.log("after cancel");

      // remove the existing file-upload-icon div element
      document.body.removeChild(document.getElementsByClassName("file-upload-icon")[0]);


      console.log("selected file is null")
      // create a div element className "file-upload-icon"
      var fileUploadIcons = document.createElement("div");
      fileUploadIcons.className = "file-upload-icon";
      // add this div element div app 
      // document.getElementById("app").appendChild(fileUploadIcons);


      // <i id = "preloaded_data_1" className="blue huge file icon" onClick = {() => clearFileIcons("preloaded_data_1")}></i>
      // create a i element className ="blue huge file icon"
      var fileIcon1 = document.createElement("i");
      fileIcon1.className = "blue huge file icon";
      fileIcon1.id = "preloaded_data_1";
      // fileIcon1.onclick = function () { clearFileIcons("preloaded_data_1") };
      // add this i element to the div element
      // fileUploadIcons.appendChild(fileIcon1);


      //  <i id = "preloaded_data_2" className="red huge file icon" onClick = {() => clearFileIcons("preloaded_data_2")}></i>
      // create a i element className ="red huge file icon"
      var fileIcon2 = document.createElement("i");
      fileIcon2.className = "red huge file icon";
      fileIcon2.id = "preloaded_data_2";
      // fileIcon2.onclick = function () { clearFileIcons("preloaded_data_2") };
      // add this i element to the div element
      // fileUploadIcons.appendChild(fileIcon2);


      //  <i id = "preloaded_data_3" className="green huge file icon" onClick = {() => clearFileIcons("preloaded_data_3")}></i>
      // create a i element className ="green huge file icon"
      var fileIcon3 = document.createElement("i");
      fileIcon3.className = "green huge file icon";
      fileIcon3.id = "preloaded_data_3";
      // fileIcon3.onclick = function () { clearFileIcons("preloaded_data_3") };
      // add this i element to the div element
      // fileUploadIcons.appendChild(fileIcon3);


      //  <i id = "preloaded_data_4" className="yellow huge file icon" onClick = {() => clearFileIcons("preloaded_data_4")}></i>
      // create a i element className ="yellow huge file icon"
      var fileIcon4 = document.createElement("i");
      fileIcon4.className = "yellow huge file icon";
      fileIcon4.id = "preloaded_data_4";
      // fileIcon4.onclick = function () { clearFileIcons("preloaded_data_4") };
      // add this i element to the div element
      // fileUploadIcons.appendChild(fileIcon4);


      //  <i id = "preloaded_data_5" className="purple huge file icon" onClick = {() => clearFileIcons("preloaded_data_5")}></i>
      // create a i element className ="purple huge file icon"
      var fileIcon5 = document.createElement("i");
      fileIcon5.className = "purple huge file icon";
      fileIcon5.id = "preloaded_data_5";
      // fileIcon5.onclick = function () { clearFileIcons("preloaded_data_5") };
      // add this i element to the div element
      // fileUploadIcons.appendChild(fileIcon5);







      // // add fileUploadIcons to the body
      document.body.appendChild(fileUploadIcons);
      



      

    }

    // if current href does not include  "upload_" 

    else if (window.location.href.includes("upload_") == false) {
      clearFileIcons("preloaded_data_1");
      clearFileIcons("preloaded_data_2");
      clearFileIcons("preloaded_data_3");
      clearFileIcons("preloaded_data_4");
      clearFileIcons("preloaded_data_5");
    

    }

    // find div elements ,whose id string incluses mydiv, mydiv1, mydiv2, mydiv3, mydiv4, mydiv5.


    


    // make id iconshome unvisible
    document.getElementById("iconshome").style.visibility = "hidden";
    

    function openTrueOrFalse_file_upload_popup(){
      if (localStorage.getItem("file_upload_popup") == "true"){
  
        // if (document.getElementById("aiTooglePopup")!==null){
        //   document.getElementById("aiTooglePopup").style.cssText = "display: block !important";
        // }
  
        
        return false;
      }
      else{
        return true;
      }
      
  
    }
  


    

    //Main UI elements
    //
    return (
      

      <div> 
        <SceneHeader header="Upload Datasets"/>

       

        <Form inverted>

          <Popup
            id = "file_upload_popup"
            trigger={
          <Segment className="file-upload-segment">
            
            {/* File dropzone/chooser */}
            {fileInputElem}

                 
            <br/>



            

            <div
              id="file-upload-form-input-area"
              className={formInputClass}
            >

            <Divider inverted horizontal>
              <Header inverted as='h4'>
                Specification
              </Header>
            </Divider>
          
            {/*dropdowns for selecting dep. feature and prediction type*/}
            {userDatasetOptions}

            {/*buttons for specifying feature types*/}
            <Form.Field
                label="Features Types"
                style={{marginTop: '1em'}}
            />
            {userFeatureTypeControls}

            {/*upload button*/}
            <Divider inverted horizontal>
              <Header inverted as='h4'> Upload </Header>
            </Divider>

            <Form.Field style={{float: 'right'}}>
              {/* Cancel button */}
              <Button 
                onClick={() => this.resetState()}
                inverted               
                className="file-upload-button"
                color='red' 
                content="Cancel"
              />
              {/* Upload Button */}
              <Button
                inverted
                color="blue"
                disabled={this.state.uploadButtonDisabled}
                loading={this.state.uploadButtonDisabled}
                icon="upload"
                content="Upload Dataset"
                className="file-upload-button"
                onClick={this.handleUpload}
              />
            </Form.Field>
            </div>
            
          </Segment>
            }
            // if {fileInputElem} is undefined, then show content "hello"
            // if {fileInputElem} is defined, then show content "world"
            // if target is selected then make the popup disappear


            
            content={this.state.selectedFile == null ? "Upload your file." : "Set target, prediction type, feature types, and click the 'upload dataset' button."}
            
            // content={this.targetSelected  == null  ? "Set prediction type, feature types, and upload." : "Set target, prediction type, feature types, and upload."}
            // content="Upload a csv or tsv file"??
            position="right center"
            
            open = {openTrueOrFalse_file_upload_popup()}

            // open = {this.state.file_upload_popup == undefined ? true : false}

            onClick = { () => 
              {
                if (document.getElementById("file_upload_popup") != null) {
                
                  document.getElementById("file_upload_popup").style.cssText += ';display:none !important;';

                  this.state.file_upload_popup = "none";

                  localStorage.setItem("file_upload_popup", "true");
                  // show the local storage on the console
                  console.log("file_upload_popup", localStorage.getItem("file_upload_popup"));
                
                }
              }
            }
           



          />

        
        

        
        
        </Form>

        
       
        {dataPrevTable}
      </div>

      


    );
  }
}

const mapStateToProps = (state) => ({
  dataset: state.dataset
});

export { FileUpload };
export default connect(mapStateToProps, { fetchDatasets, uploadDataset })(FileUpload);









// // tooltip for "Upload Dataset" page
// document.addEventListener("DOMContentLoaded", function(e) {
//   const x = document.getElementById("app");
//   // find any elements with the tag name "a" with Hello Add new"
//   const y = x.getElementsByTagName("a");

//   // show content of the first element with the tag name "a"
//   // y.
//   // if y lentgh is 0, then wait for 1 second and try again
//   if (y.length == 0) {
//     setTimeout(function() {
    

//       // original code
//       // .tooltip {
//       //   position: relative;
//       //   display: inline-block;
//       //   border-bottom: 1px dotted black;
//       // }
      
//       // .tooltip .tooltiptext {
//       //   visibility: visible;
//       //   width: 120px;
//       //   background-color: #555;
//       //   color: #fff;
//       //   text-align: center;
//       //   border-radius: 6px;
//       //   padding: 5px 0;
//       //   position: absolute;
//       //   z-index: 1;
//       //   bottom: 125%;
//       //   left: 50%;
//       //   margin-left: -60px;
//       //   opacity: 1;
//       //   transition: opacity 0.3s;
//       // }
      
//       // .tooltip .tooltiptext::after {
//       //   visibility: visible;
//       //   content: "";
//       //   position: absolute;
//       //   top: 100%;
//       //   left: 50%;
//       //   margin-left: -5px;
//       //   border-width: 5px;
//       //   border-style: solid;
//       //   border-color: #555 transparent transparent transparent;
//       // }
      
//       // .tooltip:hover .tooltiptext {
//       //   visibility: hidden;
//       //   opacity: 1;
//       // }

      

//     var styles = `
//     .tooltip {
//       position: relative;
//       display: inline-block;
//       border-bottom: 1px dotted black;
//     }
    
//     .tooltip .tooltiptext {
//       visibility: visible;
//       width: 120px;
//       background-color: #555;
//       color: #fff;
//       text-align: center;
//       border-radius: 6px;
//       padding: 5px 0;
//       position: absolute;
//       z-index: 1;
//       bottom: 15%;
//       left: 110%;
//       margin-left: 0px;
//       opacity: 1;
//       transition: opacity 0.3s;
//     }
    
//     .tooltip .tooltiptext::after {
//       content: "";
//       position: absolute;
//       top: 30%;
//       left: -8.3%;
//       margin-left: 0px;
//       border-width: 5px;
//       border-style: solid;
//       border-color: transparent #555 transparent transparent;
//     }
    
//     .tooltip:hover .tooltiptext {
//       visibility: hidden;
//       opacity: 0;
// `

    

//     // visibility: visible;
//     // width: 120px;
//     // background-color: #555;
//     // color: #fff;
//     // text-align: center;
//     // border-radius: 6px;
//     // padding: 5px 0;
//     // position: absolute;
//     // z-index: 1;
//     // bottom: 50%;
//     // left: 100%;
//     // margin-left: 0px;
//     // opacity: 1;
//     // transition: opacity 0.3s;



//     // var styleSheet = document.createElement("style")
    
//     var styleSheet = document.getElementsByTagName("style")
//     styleSheet.innerText += styles
//     document.head.appendChild(styleSheet)

//     // <div class="tooltip">Hover over me
//         // <span class="tooltiptext">Tooltip text</span>
//     // </div>

//     // create a div with class tooltip and html content "Hover over me"
//     var div_test = document.createElement("div");
//     div_test.className = "tooltip";
//     // div_test.innerHTML = "Hover over me";
//     div_test.innerHTML = "_";
//     // background color is white
//     div_test.style.backgroundColor = "white";
//     // do not show div_test
//     // div_test.style.display = "none";

//     // create a span with class tooltiptext and html content "Tooltip text"
//     var span_test = document.createElement("span");
//     span_test.className = "tooltiptext";
//     span_test.innerHTML = "step 1: add new data";

//     // make span_test always visible
//     span_test.style.visibility = "visible";

 
    
 
    




   




//     // locate the span_test right of the div_test
//     // span_test.style.left = "100%";
//     // span_test.style.top = "0";
//     // span_test.style.marginLeft = "5px";
//     // span_test.style.marginTop = "-5px";


//     // make span_test always block whever div_test is hovered or not
//     span_test.style.display = "block";
    

//     // append span_test to div_test
//     div_test.appendChild(span_test);


//     // append div_test to app
//     // document.getElementById("app").appendChild(div_test);



//     // real version
//     const x = document.getElementById("app");
//     // find any elements with the tag name "a" with Hello Add new"
//     const y = x.getElementsByTagName("a");
//     // add mouse over event to the div

    

//     // if current url includes "upload_dataset"
//     if (window.location.href.includes("upload_dataset")) {

//       console.log("pathname")
   
//       console.log(window.location.href)

//       // find any elements with the tag name "div" with class dropzone"
//       const z = x.getElementsByTagName("div");
      
//       // find any divs with class dropzone
//       for (var i = 0; i < z.length; i++) {
//         if (z[i].className.includes("dropzone")) {
//           // add .appendChild(span_test);
//           z[i].appendChild(span_test);
//         }
//       }
  

      
      
//     }
    


//   }, 1000);
//   } 
 
// });





// tooltip for "Upload Dataset" page
// document.addEventListener("DOMContentLoaded", function(e) {

//   // setTimeout(() => {
//   //   //wait until the section is loaded
//   //   const section = document.getElementsByTagName("section")[0];
  
//   //         if (section) {
//   //           section.addEventListener("mouseover", function( event ) {
//   //         // console.log("mouseover on dropzone");

//   //         // document.getElementById("span_upload_dataset").style.visibility = "hidden";
//   //         if (document.getElementById("span_upload_dataset").style.visibility == "hidden")
//   //         {
//   //           document.getElementById("span_upload_dataset").style.visibility = "visible";
//   //           console.log("document.getElementById(span_upload_dataset).style.visibility = visible");
//   //         }
//   //         else
//   //         {
//   //           document.getElementById("span_upload_dataset").style.visibility = "hidden";
//   //           console.log("document.getElementById(span_upload_dataset).style.visibility = hidden");
//   //         }
          
//   //         // span_test.style.visibility = "hidden";
        
//   //       }, false);
//   //     }
//   // }, 1000); 

//   //wait until the section is loaded



//       // const section = document.getElementsByTagName("section")[0];
      
//       // // y[0] mouseover event
      
//       // section.addEventListener("mouseover", function( event ) {
//       //   // console.log("mouseover on dropzone");

//       //   // document.getElementById("span_upload_dataset").style.visibility = "hidden";
//       //   if (document.getElementById("span_upload_dataset").style.visibility == "hidden")
//       //   {
//       //     document.getElementById("span_upload_dataset").style.visibility = "visible";
//       //     console.log("document.getElementById(span_upload_dataset).style.visibility = visible");
//       //   }
//       //   else
//       //   {
//       //     document.getElementById("span_upload_dataset").style.visibility = "hidden";
//       //     console.log("document.getElementById(span_upload_dataset).style.visibility = hidden");
//       //   }
        
//       //   // span_test.style.visibility = "hidden";
      
//       // } , false);
 
// });






// document.addEventListener("DOMContentLoaded", function(e) {
  
 
  
//     setTimeout(function() {
    

      

    

//    var preloaded_data_1 = document.getElementById("preloaded_data_1");
   
//   //  add to the document.getElementById("mydiv")
//    document.getElementById("mydivheader").appendChild(preloaded_data_1);

    


    


//   }, 500);
  
 
// });