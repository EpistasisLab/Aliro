/* ~This file is part of the Aliro library~

Copyright (C) 2023 Epistasis Lab, 
Center for Artificial Intelligence Research and Education (CAIRE),
Department of Computational Biomedicine (CBM),
Cedars-Sinai Medical Center.

Aliro is maintained by:
    - Hyunjun Choi (hyunjun.choi@cshs.org)
    - Miguel Hernandez (miguel.e.hernandez@cshs.org)
    - Nick Matsumoto (nicholas.matsumoto@cshs.org)
    - Jay Moran (jay.moran@cshs.org)
    - and many other generous open source contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

(Autogenerated header, do not modify)

*/
import React, { Component } from 'react';

import c3 from 'c3';

import d3 from 'd3';

    
class ScatterPlot extends Component {


  componentDidMount() {
    const { Points, Labels, chartKey, chartColor } = this.props;
    Points && Labels && this.renderChart(Points, Labels, chartKey, chartColor);
  }


  renderChart(Points, Labels, chartKey, chartColor) {





     // if chartKey includes pca, then 
     if (chartKey.includes('pca')) {
      var axis= {
        x: {
            label: 'PC1',
            tick: {
                fit: false
            }
        },
        y: {
            label: 'PC2'
        }
      }
      // else if chartKey includes tsne, then
    } 
    else if (chartKey.includes('tsne')) {
      var axis= {
        x: {
            label: 'Comp 1',
            tick: {
                fit: false
            }
        },
        y: {
            label: 'Comp 2'
        }
      }
    }

    // // make axis tick values like this 30000-> 3 units 10000
    // axis: {
    //   x: {
    //     tick: {
    //       format: d3.format("s")
    //     }
    //   }
    // },

    else if (chartKey.includes('CVP')) {
      var i=0;
      var axis= {
        x: {
            label: 'Observed Values',
            tick: {
                fit: false
                

                // format: d3.format(".2s"),
                // make only three ticks on x axis except for the first and last tick
                // format: d3.format(".2s")

                // remove the first and last tick

                // format: function (d) {
                //   console.log('d: ', d)
                //   if (d === 0 || d === 1) {
                //     return null;
                //   }
                //   return d;
                // },
                // d and index

                // format: function (d) {
                //   d3.format(".2s")
                //   console.log('d: ', d)
                //   console.log('i: ', i)
                //   if (i === 0 || i === 1) {
                //     i++;
                //     return null;
                //   }
                //   i++;
                //   return d;
                // },

                
                // count: 3

            },
            // make only three ticks on x axis except for the first and last tick
            // tick: {
            //   values: [0, 0.5, 1],
            //   count: 3


            
        },
        y: {
            label: 'Predicted Values',
            tick: {
              // fit: false
              format: d3.format(".2s")
          },
        }
      }
    }

    else if (chartKey.includes('CVR')) {
      var axis= {
        x: {
            label: 'Predicted Values',
            tick: {
                // fit: false
                format: d3.format(".1s")
            }
        },
        y: {
            label: 'Residuals'
        }
      }
    }

    else if (chartKey.includes('QQNR')) {
      var axis= {
        x: {
            label: 'Theoretical Quantiles',
            tick: {
                // fit: false
                format: d3.format(".1s")
            }
        },
        y: {
            label: 'Ordered Normal Quantiles'
        }
      }
    }

    

  
    // calculate how many kinds of labels are there in Labels
    var labelSet = new Set(Labels);

    // convert labelSet to array
    var labelSet = Array.from(labelSet);

 
    var labelSetLength = labelSet.length;

   
    var columns =[];
    var xs = {};

    var xArray_float = [];
    var yArray_float = [];

    for (var i = 0; i < labelSetLength; i++) {
      
      var xArray = [];
      var yArray = [];

      xArray.push(labelSet[i].toString()+'_x');
      

      if (chartKey.includes('pca') || chartKey.includes('tsne')) {
        yArray.push('class_'+labelSet[i].toString());
        xs['class_'+labelSet[i].toString()] = labelSet[i].toString()+'_x';

      }

      if (chartKey.includes('CVP') || chartKey.includes('CVR') || chartKey.includes('QQNR')) {
        yArray.push('Points');
        xs['Points'] = labelSet[i].toString()+'_x';

      }


      for (var j = 0; j < Points.length; j++) {
        if (Labels[j] == labelSet[i]) {
          xArray.push(Points[j][0]);
          yArray.push(Points[j][1]);

          xArray_float.push(Points[j][0]);
          yArray_float.push(Points[j][1]);
        }
      }

      columns.push(xArray);
      columns.push(yArray);
    }

    // console.log('xs: ', xs);
    // Sort xs by the key
    var xsSorted = {};
    Object.keys(xs).sort().forEach(function(key) {
      xsSorted[key] = xs[key];
    });



    if (chartKey.includes('CVP') || chartKey.includes('QQNR')) {

      console.log('inside of cvp, cvr, qqnr');

      console.log('xArray_float: ', xArray_float);

      // minimum value of xArray_float
      console.log('Math.min.apply(null, xArray_float): ', Math.min.apply(null, xArray_float));

      // maximum value of xArray_float
      console.log('Math.max.apply(null, xArray_float): ', Math.max.apply(null, xArray_float));


    
    // minimum value of xArray_float
    var xMin = Math.min.apply(null, xArray_float);

    // maximum value of xArray_float
    var xMax = Math.max.apply(null, xArray_float);
    

    


  // ['line_x', 1,100],
  // ['line_y', 1,100]
  // ['line_x', xMin,xMax],
  // ['line_y', xMin,xMax]

    var temp_x = ['line_x', xMin,xMax];
    var temp_y = ['Slope', xMin,xMax];

    columns.push(temp_x);
    columns.push(temp_y);

    // Slope
    xsSorted['Slope'] = 'line_x';

    }



    if (chartKey.includes('CVR')) {

      console.log('inside of cvp, cvr, qqnr');

      console.log('xArray_float: ', xArray_float);

      // minimum value of xArray_float
      console.log('Math.min.apply(null, xArray_float): ', Math.min.apply(null, xArray_float));

      // maximum value of xArray_float
      console.log('Math.max.apply(null, xArray_float): ', Math.max.apply(null, xArray_float));


    
      // minimum value of xArray_float
      var xMin = Math.min.apply(null, xArray_float);

      // maximum value of xArray_float
      var xMax = Math.max.apply(null, xArray_float);
      

      


      var temp_x = ['line_x', xMin,xMax];
      var temp_y = ['ResidualZeroLine', 0,0];

      columns.push(temp_x);
      columns.push(temp_y);


      xsSorted['ResidualZeroLine'] = 'line_x';

    }



    xs = xsSorted;


    console.log('xs: ', xs);
    console.log('columns: ', columns);






if (chartKey.includes('pca') || chartKey.includes('tsne')) {

  var chart = c3.generate({
    bindto: `.${chartKey}`,
    data: {
        
        xs: xsSorted,
        columns: columns,
        type: 'scatter'
    },
    axis: axis,
    // set tooltip based on your setting 
    tooltip: {
      // format: {
      //   title: function (d,name) { return  d,name; },

      // }
      // do not show tooltip
      show: false
    },
    legend: {
      show: false
    },
  });
}



// scatter plot and dashed line for 1:1
// var chart = c3.generate({
//   data: {

      
      
//       xs: {'class_0':"0_x", 'class_1':"1_x", 'class_2':"2_x",'line_y':"line_x"},
      
//       columns: [
//           ["2_x", 1,1,3,4,2],
//           ['class_2', 300, 200, 160, 400, 250, 250],
//           ['1_x', 200, 130, 90, 240, 130, 220],
//           ['class_1', 200, 120, 150, 140, 160, 150],
//           ['0_x', 90, 70, 20, 50, 60, 120],
//           ['class_0', 200, 120, 150, 140, 160, 150],
//           ['line_x', 1,100],
//           ['line_y', 1,100]
          
//       ],
//       type: 'scatter',
      
//       types: {
          
          
//           line_y: 'line'
          
          
//       },
//       regions: {
//         'line_y': [{'style':'dashed'}], // currently 'dashed' style only
        
//       },
//       colors: {
//     line_y: '#FF0000'
// }
      
//   }
// });

else if (chartKey.includes('CVP') || chartKey.includes('QQNR')) {

  var chart = c3.generate({
    bindto: `.${chartKey}`,
    data: {
        
        xs: xsSorted,
        columns: columns,
        type: 'scatter',
          
        types: {
            
            
            Slope: 'line'

        },
        regions: {
          'Slope': [{'style':'dashed'}], // currently 'dashed' style only
          
        },
        colors: {
          // red
          Slope: '#FF0000'
      }
    },
    axis: axis,
    


    // set tooltip based on your setting 
    tooltip: {
      // format: {
      //   title: function (d,name) { return  d,name; },

      // }
      // do not show tooltip
      show: false
    },

    legend: {
      item: { onclick: function () {
        console.log('legend item clicked')
      } }
    }


  });
}


else if (chartKey.includes('CVR')) {

  var chart = c3.generate({
      
    bindto: `.${chartKey}`,
    data: {
        
        xs: xsSorted,
        columns: columns,
        type: 'scatter',
          
        types: {
            
            
          ResidualZeroLine: 'line'

        },
        regions: {
          'ResidualZeroLine': [{'style':'dashed'}], // currently 'dashed' style only
          
        },
        colors: {
          // red
          ResidualZeroLine: '#FF0000'
      }
    },
    axis: axis,
    // set tooltip based on your setting 
    tooltip: {
      // format: {
      //   title: function (d,name) { return  d,name; },

      // }
      // do not show tooltip
      show: false
    },
    legend: {
      
      item: { onclick: function (id) {

        console.log('id: ', id)

        
        
        console.log('legend item clicked')
      } }
    }
  });
}
  




  }

  render() {
    return (
      // <div className={`ScatterPlot ${this.props.chartKey}`} />


      




    <div >
        
        {/* <svg className={`ScatterPlot ${this.props.chartKey}`} viewBox="0 0 520 400" preserveAspectRatio="xMinYMin meet" >
            
        </svg> */}

        

        {/* set viewBox based on window.innerWidth and window.innerHeight  */}
        {/* <svg className={`ScatterPlot ${this.props.chartKey}`} viewBox={`0 0 ${window.innerWidth*0.3} ${window.innerHeight*0.3}`} preserveAspectRatio="xMinYMin meet" > */}
        
        <svg 
        className={`ScatterPlot ${this.props.chartKey}`} 
        // make viewPort responsive
        
        viewBox={`0 0 ${window.innerWidth*0.3} ${window.innerHeight*0.3}`} preserveAspectRatio="xMinYMin meet" >
          </svg>
    </div>
    );
  }
}

ScatterPlot.defaultProps = {
  chartColor: '#60B044'
};

export default ScatterPlot;








