/* ~This file is part of the Aliro library~

Copyright (C) 2023 Epistasis Lab, 
Center for Artificial Intelligence Research and Education (CAIRE),
Department of Computational Biomedicine (CBM),
Cedars-Sinai Medical Center.

Aliro is maintained by:
    - Hyunjun Choi (hyunjun.choi@cshs.org)
    - Miguel Hernandez (miguel.e.hernandez@cshs.org)
    - Nick Matsumoto (nicholas.matsumoto@cshs.org)
    - Jay Moran (jay.moran@cshs.org)
    - and many other generous open source contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

(Autogenerated header, do not modify)

*/
import React, { Component } from 'react';

import c3 from 'c3';

import d3 from 'd3';



// working version
class ScatterPlot extends Component {


  // Points={Points}
  // Labels ={Labels}
  // chartKey={chartKey}
  // chartColor={chartColor}

  componentDidMount() {
    const { Points, Labels, chartKey, chartColor } = this.props;
    Points && Labels && this.renderChart(Points, Labels, chartKey, chartColor);
  }
/*
colors: {
  'test_score': '#0072b2',  ---- light blue
  'train_score': '#f0e442'  ---- light yellow
  '#55D6BE' ----- light sea green
}

use anonymous function to 'disable' interaction
look here - https://github.com/c3js/c3/issues/493#issuecomment-456686654
*/

  // renderChart(expList, chartKey, chartColor, min, max) {
  renderChart(Points, Labels, chartKey, chartColor) {





     // if chartKey includes pca, then 
     if (chartKey.includes('pca')) {
      var axis= {
        x: {
            label: 'PC1',
            tick: {
                fit: false
            }
        },
        y: {
            label: 'PC2'
        }
      }
      // else if chartKey includes tsne, then
    } 
    else if (chartKey.includes('tsne')) {
      var axis= {
        x: {
            label: 'Comp 1',
            tick: {
                fit: false
            }
        },
        y: {
            label: 'Comp 2'
        }
      }
    }

    else if (chartKey.includes('CVP')) {
      var axis= {
        x: {
            label: 'Observed Values',
            tick: {
                fit: false
            }
        },
        y: {
            label: 'Predicted Values'
        }
      }
    }

    else if (chartKey.includes('CVR')) {
      var axis= {
        x: {
            label: 'Predicted Values',
            tick: {
                fit: false
            }
        },
        y: {
            label: 'Residuals'
        }
      }
    }

    else if (chartKey.includes('QQNR')) {
      var axis= {
        x: {
            label: 'Theoretical Quantiles',
            tick: {
                fit: false
            }
        },
        y: {
            label: 'Ordered Normal Quantiles'
        }
      }
    }

    

  
    // calculate how many kinds of labels are there in Labels
    var labelSet = new Set(Labels);

    // convert labelSet to array
    var labelSet = Array.from(labelSet);

 
    var labelSetLength = labelSet.length;

   
    var columns =[];
    var xs = {};

    var xArray_float = [];
    var yArray_float = [];

    for (var i = 0; i < labelSetLength; i++) {
      // create x and y array for each label
      var xArray = [];
      var yArray = [];

      xArray.push(labelSet[i].toString()+'_x');
      // yArray.push(labelSet[i].toString()+'_y');
      // yArray.push(labelSet[i].toString());
      // yArray.push('class_'+labelSet[i].toString());
      // yArray.push('Points');


      // xs[labelSet[i].toString()+'_y'] = labelSet[i].toString()+'_x';
      // xs[labelSet[i].toString()] = labelSet[i].toString()+'_x';
      // xs['class_'+labelSet[i].toString()] = labelSet[i].toString()+'_x';
      // xs['Points'] = labelSet[i].toString()+'_x';

      if (chartKey.includes('pca') || chartKey.includes('tsne')) {
        yArray.push('class_'+labelSet[i].toString());
        xs['class_'+labelSet[i].toString()] = labelSet[i].toString()+'_x';

      }

      if (chartKey.includes('CVP') || chartKey.includes('CVR') || chartKey.includes('QQNR')) {
        yArray.push('Points');
        xs['Points'] = labelSet[i].toString()+'_x';

      }
      // xs[labelSet[i]] = labelSet[i]+'_x';

      for (var j = 0; j < Points.length; j++) {
        if (Labels[j] == labelSet[i]) {
          xArray.push(Points[j][0]);
          yArray.push(Points[j][1]);

          xArray_float.push(Points[j][0]);
          yArray_float.push(Points[j][1]);
        }
      }

      columns.push(xArray);
      columns.push(yArray);
    }

    // console.log('xs: ', xs);
    // Sort xs by the key
    var xsSorted = {};
    Object.keys(xs).sort().forEach(function(key) {
      xsSorted[key] = xs[key];
    });

    // console.log('xsSorted: ', xsSorted);



    if (chartKey.includes('CVP') || chartKey.includes('QQNR')) {

      console.log('inside of cvp, cvr, qqnr');

      console.log('xArray_float: ', xArray_float);

      // minimum value of xArray_float
      console.log('Math.min.apply(null, xArray_float): ', Math.min.apply(null, xArray_float));

      // maximum value of xArray_float
      console.log('Math.max.apply(null, xArray_float): ', Math.max.apply(null, xArray_float));


    
    // minimum value of xArray_float
    var xMin = Math.min.apply(null, xArray_float);

    // maximum value of xArray_float
    var xMax = Math.max.apply(null, xArray_float);
    

    


  // ['line_x', 1,100],
  // ['line_y', 1,100]

  // ['line_x', xMin,xMax],
  // ['line_y', xMin,xMax]

    var temp_x = ['line_x', xMin,xMax];
    var temp_y = ['Slope', xMin,xMax];

    columns.push(temp_x);
    columns.push(temp_y);

    // Slope
    xsSorted['Slope'] = 'line_x';

    }



    if (chartKey.includes('CVR')) {

      console.log('inside of cvp, cvr, qqnr');

      console.log('xArray_float: ', xArray_float);

      // minimum value of xArray_float
      console.log('Math.min.apply(null, xArray_float): ', Math.min.apply(null, xArray_float));

      // maximum value of xArray_float
      console.log('Math.max.apply(null, xArray_float): ', Math.max.apply(null, xArray_float));


    
      // minimum value of xArray_float
      var xMin = Math.min.apply(null, xArray_float);

      // maximum value of xArray_float
      var xMax = Math.max.apply(null, xArray_float);
      

      


      var temp_x = ['line_x', xMin,xMax];
      var temp_y = ['ResidualZeroLine', 0,0];

      columns.push(temp_x);
      columns.push(temp_y);


      xsSorted['ResidualZeroLine'] = 'line_x';

    }



    xs = xsSorted;


    console.log('xs: ', xs);
    console.log('columns: ', columns);






if (chartKey.includes('pca') || chartKey.includes('tsne')) {

  var chart = c3.generate({
    bindto: `.${chartKey}`,
    data: {
        
        xs: xsSorted,
        columns: columns,
        type: 'scatter'
    },
    axis: axis,
    // set tooltip based on your setting 
    tooltip: {
      // format: {
      //   title: function (d,name) { return  d,name; },

      // }
      // do not show tooltip
      show: false
    }
  });
}



// scatter plot and dashed line for 1:1
// var chart = c3.generate({
//   data: {

      
      
//       xs: {'class_0':"0_x", 'class_1':"1_x", 'class_2':"2_x",'line_y':"line_x"},
      
//       columns: [
//           ["2_x", 1,1,3,4,2],
//           ['class_2', 300, 200, 160, 400, 250, 250],
//           ['1_x', 200, 130, 90, 240, 130, 220],
//           ['class_1', 200, 120, 150, 140, 160, 150],
//           ['0_x', 90, 70, 20, 50, 60, 120],
//           ['class_0', 200, 120, 150, 140, 160, 150],
//           ['line_x', 1,100],
//           ['line_y', 1,100]
          
//       ],
//       type: 'scatter',
      
//       types: {
          
          
//           line_y: 'line'
          
          
//       },
//       regions: {
//         'line_y': [{'style':'dashed'}], // currently 'dashed' style only
        
//       },
//       colors: {
//     line_y: '#FF0000'
// }
      
//   }
// });

else if (chartKey.includes('CVP') || chartKey.includes('QQNR')) {

  var chart = c3.generate({
    bindto: `.${chartKey}`,
    data: {
        
        xs: xsSorted,
        columns: columns,
        type: 'scatter',
          
        types: {
            
            
            Slope: 'line'

        },
        regions: {
          'Slope': [{'style':'dashed'}], // currently 'dashed' style only
          
        },
        colors: {
          // red
          Slope: '#FF0000'
      }
    },
    axis: axis,
    // set tooltip based on your setting 
    tooltip: {
      // format: {
      //   title: function (d,name) { return  d,name; },

      // }
      // do not show tooltip
      show: false
    }
  });
}


else if (chartKey.includes('CVR')) {

  var chart = c3.generate({
    bindto: `.${chartKey}`,
    data: {
        
        xs: xsSorted,
        columns: columns,
        type: 'scatter',
          
        types: {
            
            
          ResidualZeroLine: 'line'

        },
        regions: {
          'ResidualZeroLine': [{'style':'dashed'}], // currently 'dashed' style only
          
        },
        colors: {
          // red
          ResidualZeroLine: '#FF0000'
      }
    },
    axis: axis,
    // set tooltip based on your setting 
    tooltip: {
      // format: {
      //   title: function (d,name) { return  d,name; },

      // }
      // do not show tooltip
      show: false
    }
  });
}
  




  }

  render() {
    return (
      <div className={`ScatterPlot ${this.props.chartKey}`} />
    );
  }
}

ScatterPlot.defaultProps = {
  chartColor: '#60B044'
};

export default ScatterPlot;











// test version
// class ScatterPlot extends Component {
//   componentDidMount() {
//     const { expList, chartKey, chartColor, min, max } = this.props;
//     expList && this.renderChart(expList, chartKey, chartColor, min, max);
//   }
// /*
// colors: {
//   'test_score': '#0072b2',  ---- light blue
//   'train_score': '#f0e442'  ---- light yellow
//   '#55D6BE' ----- light sea green
// }

// use anonymous function to 'disable' interaction
// look here - https://github.com/c3js/c3/issues/493#issuecomment-456686654
// */

//   renderChart(expList, chartKey, chartColor, min, max) {
//     // window.console.log('exp list: ');
//     // window.console.log('exp list: ', expList);
//     // print d3 version
//     window.console.log('d3 version: ', d3.version);
//     // print c3 version
//     window.console.log('c3 version: ', c3.version);



//     // make expList like[['1',0.2],['2',0.3],['3',0.5]]
//     // expList = [['1',0.2],['2',0.3],['3',0.5]];

//     // print expList
//     window.console.log('expList: ', expList);

//     // print chartKey
//     window.console.log('chartKey: ', chartKey);

//     // var chart = c3.generate({
//     //   bindto: `.${chartKey}`,
//     //   data: {
          

//     //       columns:expList
//     //       ,
          
//     //       type : 'ScatterPlot',
//     //       // colors: {
//     //       //   columns[0][0]: '#ff0000',
//     //       //   columns[1][0]: '#00ff00'
//     //       // }
//     //       // ,
//     //       onclick: function (d, i) { console.log("onclick", d, i); },
//     //       onmouseover: function (d, i) { console.log("onmouseover", d, i); },
//     //       onmouseout: function (d, i) { console.log("onmouseout", d, i); }
//     //   },
//     //   ScatterPlot: {
//     //       // title: "Iris Petal Width"
//     //       title: ""
//     //       // title: expList
//     //   }
//     // });




//      // make confusion matrix [[10,20],[30,40]] using d3.js
//     var matrix = [[10,20],[30,40]];
   


//     // print curreht class name
//     window.console.log('current class name: ', `.${chartKey}`);

    

//       var div = d3.select(`.${chartKey}`)
//       // add svg to div 
//       var svg = div.append("svg")

//       var rect = svg.selectAll("rect")
//       .data(matrix)
//       .enter()
//       .append("rect")
//       .attr("width", 100)
//       .attr("height", 100)
//       // make width and height related to current div size
//       // .attr("width", function(d, i) {
//       //   return d3.select(`.${chartKey}`).node().getBoundingClientRect().width/10;
//       // })
//       // .attr("height", function(d, i) {
//       //   return d3.select(`.${chartKey}`).node().getBoundingClientRect().height/10;
//       // })
//       .attr("x", function(d, i) {
//         return i * 50;
//       } )
//       .attr("y", function(d, i) {
//         return i * 50;
//       }
//       )
//       .attr('id', function(d, i) {
//         return 'rect_' + i;
//       }
//       )
//       .attr('fill', function(d, i) {
//         return 'red';
//       } 
//       )
//       // make it show more than background color
//       .attr('opacity', 0.5)
//       // add mouseover event
//       .on("mouseover", function(d, i) {
//         // change color
//         d3.select(this).attr('fill', 'blue');
//         console.log('number',d)
//         // show this d as string on the rect
//         d3.select(this).text(d);
//         // make the text color white
//         d3.select(this).attr('fill', 'white');

//         d3.select(this).text('This is some information about whatever')
//                 .attr('x', 50)
//                 .attr('y', 150)
//                 .attr('fill', 'white')

//       })
//       .append('text').text('test');
//       // add data value to each rect text


//       // matrix 
//       //  20  30
//       //  40  50

//       // add the matrix value to rect 

//       // var text = svg.selectAll("text")
//       // .data(matrix)
//       // .enter()
//       // .append("text")


  

//   }

//   render() {
//     return (
//       <div className={`ScatterPlot ${this.props.chartKey}`} />
//     );
//   }
// }

// ScatterPlot.defaultProps = {
//   chartColor: '#60B044'
// };

// export default ScatterPlot;







