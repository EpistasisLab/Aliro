/* ~This file is part of the Aliro library~

Copyright (C) 2023 Epistasis Lab,
Center for Artificial Intelligence Research and Education (CAIRE),
Department of Computational Biomedicine (CBM),
Cedars-Sinai Medical Center.

Aliro is maintained by:
    - Hyunjun Choi (hyunjun.choi@cshs.org)
    - Miguel Hernandez (miguel.e.hernandez@cshs.org)
    - Nick Matsumoto (nicholas.matsumoto@cshs.org)
    - Jay Moran (jay.moran@cshs.org)
    - and many other generous open source contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

(Autogenerated header, do not modify)

*/
import React, { Component } from "react";
import { connect } from "react-redux";
import * as actions from "data/experiments/selected/actions";
import SceneHeader from "../SceneHeader";
import FetchError from "../FetchError";
import AlgorithmDetails from "./components/AlgorithmDetails";
import RunDetails from "./components/RunDetails";
import MSEMAEDetails from "./components/MSEMAEDetails";
import ConfusionMatrix from "./components/ConfusionMatrix";
import ConfusionMatrixJSON from "./components/ConfusionMatrixJSON";
import ROCCurve from "./components/ROCCurve";
import ShapSummaryCurve from "./components/ShapSummaryCurve";
import ImportanceScore from "./components/ImportanceScore";
import ImportanceScoreJSON from "./components/ImportanceScoreJSON";
import LearningCurve from "./components/LearningCurve";
import LearningCurveJSON from "./components/LearningCurveJSON";
import TestChart from "./components/TestChart";
import PCA from "./components/PCA";
// import PCAJSON from './components/PCAJSON';
import GenPLOT from "./components/GenPLOT";
// import PCAJSONV from './components/PCAJSONV';
// import TSNE from './components/TSNE';
// import TSNEJSON from './components/TSNEJSON';
import RegFigure from "./components/RegFigure";
import Score from "./components/Score";
// import NoScore from './components/NoScore';
import { Header, Grid, Loader, Dropdown, Menu } from "semantic-ui-react";
import { formatDataset } from "utils/formatter";
import ClassRate from "./components/ClassRate";
import ChatGPT from "../ChatGPT";

function moveSlidermakeBlack(e) {
  let block = document.getElementsByClassName("chartsbaseleft")[0];
  let slider = document.getElementsByClassName("slider")[0];
  let chatbox = document.getElementsByClassName("chatbaseright")[0];

  if (block && slider) {
    // console.log("block and slider exist");

    slider.onmousedown = function dragMouseDown(e) {
      // get width of window
      let windowWidth = window.innerWidth;
      // console.log("windowWidth", windowWidth);
      let dragX = e.clientX;
      // console.log("e.clientX", e.clientX);
      document.onmousemove = function onMouseMove(e) {
        // 0.2 --0.3 --0.4 --0.8 --

        console.log("block.offsetWidth", block.offsetWidth);

        // shift the result block to the right, and make the chatbox invisible
        if (block.offsetWidth > 0.8 * windowWidth) {
          console.log("range-bigger than 0.8");
          block.style.width = windowWidth + "px";
          dragX = e.clientX;
          chatbox.style.visibility = "hidden";
        }

        // shift the chatbox to the left, and make the result block invisible
        else if (block.offsetWidth < 0.2 * windowWidth) {
          console.log("range-smaller than 0.2");
          block.style.width = 0 + "px";
          block.style.visibility = "hidden";
          slider.style.visibility = "hidden";
          dragX = e.clientX;
        }

        // else
        // {
        //     console.log("range-bigger than or equal to 0.5 and smaller than or equal to 0.8")
        //     block.style.visibility = "block";
        //     slider.style.visibility = "block";

        //     // origin
        //     block.style.width = block.offsetWidth + e.clientX - dragX + "px";
        //     dragX = e.clientX;

        // }
        else if (
          block.offsetWidth >= 0.4 * windowWidth &&
          block.offsetWidth <= 0.8 * windowWidth
        ) {
          console.log(
            "range-bigger than or equal to 0.4 and smaller than or equal to 0.8"
          );
          block.style.visibility = "block";
          slider.style.visibility = "block";

          // origin
          block.style.width = block.offsetWidth + e.clientX - dragX + "px";
          dragX = e.clientX;

          // if e.target.parentElement.childNodes[0].childNodes[1] is not undefined

          if (
            e.target.parentElement.childNodes[0].childNodes[1].className ===
            "ui stackable two column grid"
          ) {
            e.target.parentElement.childNodes[0].childNodes[1].className =
              "ui stackable three column grid";
          } else if (
            e.target.parentElement.childNodes[0].childNodes[1].className ===
            "ui stackable one column grid"
          ) {
            e.target.parentElement.childNodes[0].childNodes[1].className =
              "ui stackable three column grid";
          }
        } else if (
          block.offsetWidth >= 0.3 * windowWidth &&
          block.offsetWidth < 0.4 * windowWidth
        ) {
          console.log("range-bigger than or equal to 0.3 and smaller than 0.4");
          block.style.visibility = "block";
          slider.style.visibility = "block";

          // origin
          block.style.width = block.offsetWidth + e.clientX - dragX + "px";
          dragX = e.clientX;

          if (
            e.target.parentElement.childNodes[0].childNodes[1].className ===
            "ui stackable three column grid"
          ) {
            e.target.parentElement.childNodes[0].childNodes[1].className =
              "ui stackable two column grid";
          } else if (
            e.target.parentElement.childNodes[0].childNodes[1].className ===
            "ui stackable one column grid"
          ) {
            e.target.parentElement.childNodes[0].childNodes[1].className =
              "ui stackable two column grid";
          }
        } else if (
          block.offsetWidth >= 0.2 * windowWidth &&
          block.offsetWidth < 0.3 * windowWidth
        ) {
          console.log("range-bigger than or equal to 0.2 and smaller than 0.3");
          block.style.visibility = "block";
          slider.style.visibility = "block";

          // origin
          block.style.width = block.offsetWidth + e.clientX - dragX + "px";
          dragX = e.clientX;

          if (
            e.target.parentElement.childNodes[0].childNodes[1].className ===
            "ui stackable three column grid"
          ) {
            e.target.parentElement.childNodes[0].childNodes[1].className =
              "ui stackable one column grid";
          } else if (
            e.target.parentElement.childNodes[0].childNodes[1].className ===
            "ui stackable two column grid"
          ) {
            e.target.parentElement.childNodes[0].childNodes[1].className =
              "ui stackable one column grid";
          }
        }
      };
      // remove mouse-move listener on mouse-up
      document.onmouseup = () =>
        (document.onmousemove = document.onmouseup = null);
    };
  }
}

function makeOriginColor(e) {
  let slider = document.getElementsByClassName("slider")[0];

  // make slider color black
  slider.style.backgroundColor = "#1B1C1D;";
}

class Results extends Component {
  constructor(props) {
    super(props);
    this.getGaugeArray = this.getGaugeArray.bind(this);
  }

  componentDidMount() {
    this.props.fetchExperiment(this.props.params.id);
  }

  componentWillUnmount() {
    this.props.clearExperiment();
  }

  /**
   * Basic helped method to create array containing [key,val] entries where
   *   key - name of given score
   *   value - actual score
   * passed to Score component which uses javascript library C3 to create graphic
   */

  getGaugeArray(keyList) {
    const { experiment } = this.props;
    let testList = [];
    let expScores = experiment.data.scores;

    if (typeof expScores === "object") {
      keyList.forEach((scoreKey) => {
        console.log("scoreKey", scoreKey);
        // in case of 0 or false, it should satisfy the condition

        if (
          expScores.hasOwnProperty(scoreKey) &&
          expScores[scoreKey] !== undefined &&
          expScores[scoreKey] !== null &&
          typeof expScores[scoreKey].toFixed === "function"
        ) {
          let tempLabel = scoreKey.includes("train")
            ? `Train (${expScores[scoreKey].toFixed(2)})`
            : `Test (${expScores[scoreKey].toFixed(2)})`;
          console.log("555-scoreKey", scoreKey);
          console.log("555-expScores[scoreKey]", expScores[scoreKey]);
          testList.push([tempLabel, expScores[scoreKey]]);
        }
      });
    }

    console.log("testList", testList);

    return testList;
  }

  render() {
    const { experiment, fetchExperiment } = this.props;

    if (experiment.isFetching || !experiment.data) {
      return (
        <Loader
          active="active"
          inverted="inverted"
          size="large"
          content="Retrieving results..."
        />
      );
    }

    if (experiment.error === "Failed to fetch") {
      return <FetchError message="The specified experiment does not exist." />;
    } else if (experiment.error) {
      return (
        <FetchError
          message={experiment.error}
          onRetry={() => fetchExperiment()}
        />
      );
    }

    const downloadModel = (id) => {
      // console.log("downloadModel_id",id)
      fetch(`/api/v1/experiments/${id}/model`)
        .then((response) => {
          if (response.status >= 400) {
            throw new Error(`${response.status}: ${response.statusText}`);
          }
          return response.json();
        })
        .then((json) => {
          console.log("json", json);
          window.location = `/api/v1/files/${json._id}`;
        });
    };

    const downloadScript = (id) => {
      fetch(`/api/v1/experiments/${id}/script`)
        .then((response) => {
          if (response.status >= 400) {
            throw new Error(`${response.status}: ${response.statusText}`);
          }
          return response.json();
        })
        .then((json) => {
          window.location = `/api/v1/files/${json._id}`;
        });
    };

    // console.log(experiment.data.prediction_type) --- get lists of scores ---
    if (experiment.data.prediction_type == "classification") {
      // classification

      console.log("experiment.data", experiment.data);
      // console.log("X_pca", experiment.data.X_pca) console.log("y_pca",
      // experiment.data.y_pca)

      let confusionMatrix,
        rocCurve,
        importanceScore,
        learningCurve,
        pca,
        pca_json,
        tsne,
        tsne_json,
        shap_explainer,
        shap_num_samples;

      let shapSummaryCurveDict = {};

      experiment.data.experiment_files.forEach(async (file) => {
        const filename = file.filename;
        console.log("filename-test", filename);
        if (filename.includes("confusion_matrix")) {
          confusionMatrix = file;
        } else if (filename.includes("roc_curve")) {
          rocCurve = file;
          // save to local storage localStorage.setItem('rocCurve', rocCurve);
        } else if (filename.includes("imp_score")) {
          importanceScore = file;
        } else if (filename.includes("learning_curve")) {
          learningCurve = file;
        } else if (filename.includes("pca") && filename.includes("png")) {
          pca = file;
          console.log("pca", pca);
        } else if (filename.includes("pca-json")) {
          console.log("pca_json");
          pca_json = file;
        } else if (filename.includes("tsne") && filename.includes("png")) {
          tsne = file;
          console.log("tsne", tsne);
        } else if (filename.includes("tsne-json")) {
          console.log("tsne_json");
          tsne_json = file;
          console.log("tsne_json: ", tsne_json);
        } else if (filename.includes("shap_summary_curve")) {
          console.log("shap_summary_curve");
          let class_name = filename.split("_").slice(-2, -1);
          shapSummaryCurveDict[class_name] = file;
          shap_explainer = experiment.data.shap_explainer;
          shap_num_samples = experiment.data.shap_num_samples;

          // save to local storage localStorage.setItem(     'shapSummaryCurveDict',
          // JSON.stringify(shapSummaryCurveDict) );
          // localStorage.setItem('shap_explainer', shap_explainer);
          // localStorage.setItem('shap_num_samples', shap_num_samples);
        } else if (filename.includes("shap_summary_json")) {
          console.log("shap_summary_json");
          // shap_json = file; console.log("shap_json: ", shap_json)
        }
      });
      // balanced accuracy
      let balancedAccKeys = [
        "train_balanced_accuracy_score",
        "balanced_accuracy_score",
      ];
      // precision scores
      let precisionKeys = ["train_precision_score", "precision_score"];
      // AUC
      let aucKeys = ["train_roc_auc_score", "roc_auc_score"];
      // f1 score
      let f1Keys = ["train_f1_score", "f1_score"];
      // recall
      let recallKeys = ["train_recall_score", "recall_score"];

      let balancedAccList = this.getGaugeArray(balancedAccKeys);
      let precisionList = this.getGaugeArray(precisionKeys);
      let aucList = this.getGaugeArray(aucKeys);
      let recallList = this.getGaugeArray(recallKeys);
      let f1List = this.getGaugeArray(f1Keys);
      let class_percentage = [];
      // let pca_data = [];

      experiment.data.class_names.forEach((eachclass) => {
        console.log("eachclass.toString()", eachclass.toString());
        // if type of experiment.data['class_' +  eachclass.toString()] === 'object'
        if (
          typeof experiment.data["class_" + eachclass.toString()] === "object"
        ) {
          class_percentage.push([
            eachclass.toString(),
            experiment.data["class_" + eachclass.toString()][0],
          ]);
          console.log("experiment.data['class_1']", experiment.data["class_1"]);
        } else {
          class_percentage.push([
            eachclass.toString(),
            experiment.data["class_" + eachclass.toString()],
          ]);
          console.log("experiment.data['class_1']", experiment.data["class_1"]);
        }
      });

      // console.log('balancedAccList', balancedAccList)  save to local storage
      // localStorage.setItem('balancedAccList', JSON.stringify(balancedAccList));
      // console.log('precisionList', precisionList)  save to local storage
      // localStorage.setItem('precisionList', JSON.stringify(precisionList));  save
      // to local storage console.log('aucList', aucList)
      // localStorage.setItem('aucList', JSON.stringify(aucList));  save to local
      // storage console.log('recallList', recallList)
      // localStorage.setItem('recallList', JSON.stringify(recallList));  save to
      // local storage console.log('f1List', f1List) localStorage.setItem('f1List',
      // JSON.stringify(f1List));  save to local storage
      // console.log('class_percentage', class_percentage)
      // localStorage.setItem('class_percentage', JSON.stringify(class_percentage));

      return (
        <div className="containerChartsChats">
          <div className="chartschat chartsbaseleft">
            <Grid columns={2} stackable="stackable">
              <Grid.Row>
                <Grid.Column>
                  <SceneHeader
                    header={`Results: ${formatDataset(
                      experiment.data.dataset_name
                    )}`}
                    subheader={`Experiment: #${experiment.data._id}`}
                  />
                </Grid.Column>
                <Grid.Column>
                  <Menu
                    compact="compact"
                    inverted="inverted"
                    floated="right"
                    color="grey"
                  >
                    <Dropdown
                      text="Download"
                      simple="simple"
                      item="item"
                      disabled={["cancelled", "fail"].includes(
                        experiment.data.status
                      )}
                    >
                      <Dropdown.Menu>
                        <Dropdown.Item
                          key="model"
                          icon="download"
                          text="Model"
                          onClick={() => downloadModel(experiment.data._id)}
                        />
                        ,
                        <Dropdown.Item
                          key="script"
                          icon="download"
                          text="Script"
                          onClick={() => downloadScript(experiment.data._id)}
                        />
                      </Dropdown.Menu>
                    </Dropdown>
                  </Menu>
                </Grid.Column>
              </Grid.Row>
            </Grid>

            <Grid columns={3} stackable="stackable">
              <Grid.Row>
                <Grid.Column>
                  <AlgorithmDetails
                    algorithm={experiment.data.algorithm}
                    params={experiment.data.params}
                  />
                  <RunDetails
                    startTime={experiment.data.started}
                    finishTime={experiment.data.finished}
                    launchedBy={experiment.data.launched_by}
                  />{" "}
                  {/* <ImportanceScore file={importanceScore} /> */}
                  <ImportanceScoreJSON
                    scoreName="Feature Importance"
                    scoreValueList={experiment.data.feature_importances}
                    featureList={experiment.data.feature_names}
                    chartKey="importance_score"
                    chartColor="#55D6BE"
                    type="classification"
                  />{" "}
                  {/* <LearningCurve file={learningCurve}/> */}
                  <LearningCurveJSON
                    scoreName="Learning Curve"
                    train_sizes={experiment.data.train_sizes}
                    train_scores={experiment.data.train_scores}
                    test_scores={experiment.data.test_scores}
                    chartKey="learning_curve"
                    chartColor="#55D6BE"
                    type="classification"
                  />
                  {/* <PCA file={pca}/> */}
                  <GenPLOT
                    scoreName="PCA 2D"
                    file={pca_json}
                    chartKey="pca_2d"
                    chartColor="#55D6BE"
                    type="classification"
                  />
                </Grid.Column>
                <Grid.Column>
                  {/* <NoScore
                  scoreName="Class Rate"
                  scoreValueList={class_percentage}
                  chartKey="test"
                  chartColor="#55D6BE"
                  type="classification"
                /> */}
                  <ClassRate
                    scoreName="Class Rate"
                    scoreValueList={class_percentage}
                    chartKey="test"
                    chartColor="#55D6BE"
                    type="classification"
                  />{" "}
                  {/* <ConfusionMatrix file={confusionMatrix} /> */}
                  {/* This TestChart is for interactive and responsive confusion matrix */}
                  <ConfusionMatrixJSON
                    scoreName="Confusion Matrix"
                    cnf_data={experiment.data.cnf_matrix}
                    chartKey="test_chart"
                    chartColor="#55D6BE"
                    type="classification"
                  />
                  <ROCCurve file={rocCurve} />
                  <ShapSummaryCurve
                    fileDict={shapSummaryCurveDict}
                    shap_explainer={shap_explainer}
                    shap_num_samples={shap_num_samples}
                  />
                  {/* <TSNE file={tsne}/> */}
                  <GenPLOT
                    scoreName="TSNE 2D"
                    file={tsne_json}
                    chartKey="tsne_2d"
                    chartColor="#55D6BE"
                    type="classification"
                  />
                </Grid.Column>
                <Grid.Column>
                  <Score
                    scoreName="Balanced Accuracy"
                    scoreValueList={balancedAccList}
                    chartKey="all"
                    chartColor="#7D5BA6"
                    type="classification"
                  />
                  <Score
                    scoreName="AUC"
                    scoreValueList={aucList}
                    chartKey="auc_scores"
                    chartColor="#55D6BE"
                    type="classification"
                  />
                  <Score
                    scoreName="Precision"
                    scoreValueList={precisionList}
                    chartKey="precision_scores"
                    chartColor="#55D6BE"
                    type="classification"
                  />
                  <Score
                    scoreName="Recall"
                    scoreValueList={recallList}
                    chartKey="recall_scores"
                    chartColor="#55D6BE"
                    type="classification"
                  />
                  <Score
                    scoreName="F1 Score"
                    scoreValueList={f1List}
                    chartKey="f1_scores"
                    chartColor="#55D6BE"
                    type="classification"
                  />
                </Grid.Column>
              </Grid.Row>
            </Grid>
          </div>
          <div
            className="slider"
            onMouseOver={moveSlidermakeBlack}
            onMouseOut={makeOriginColor}
          >
            {/* onChange={moveSlidermakeBlack} */}
            ""<br></br>
            ""<br></br>
            ""<br></br>
            ""<br></br>
            ""<br></br>
            ""<br></br>
          </div>
          <div id="chatgpt-space" className="chartschat chatbaseright">
            <ChatGPT experiment={experiment} />
          </div>
        </div>

        // <div>             <Grid columns={2} stackable="stackable"> <Grid.Row>
        // <Grid.Column> <SceneHeader                             header={`Results:
        // ${formatDataset(experiment.data.dataset_name)}`} subheader={`Experiment:
        // #${experiment.data._id}`}/> </Grid.Column>                     <Grid.Column>
        // <Menu compact="compact" inverted="inverted" floated='right' color='grey'>
        // <Dropdown                                 text='Download' simple="simple"
        // item="item" disabled={['cancelled',
        // 'fail'].includes(experiment.data.status)}> <Dropdown.Menu>
        // <Dropdown.Item key="model"
        // icon="download" text="Model"
        // onClick={() => downloadModel(experiment.data._id)}/>, <Dropdown.Item
        // key="script" icon="download"
        // text="Script" onClick={() => downloadScript(experiment.data._id)}/>
        // </Dropdown.Menu>                             </Dropdown> </Menu>
        // </Grid.Column>                 </Grid.Row> </Grid>             <Grid
        // columns={3} stackable="stackable"> <Grid.Row>
        // <Grid.Column> <AlgorithmDetails algorithm={experiment.data.algorithm}
        // params={experiment.data.params}/>                         <RunDetails
        // startTime={experiment.data.started} finishTime={experiment.data.finished}
        // launchedBy={experiment.data.launched_by}/> {/* <ImportanceScore
        // file={importanceScore} /> */}                         <ImportanceScoreJSON
        // scoreName="Feature Importance"
        // scoreValueList={experiment.data.feature_importances}
        // featureList={experiment.data.feature_names} chartKey="importance_score"
        // chartColor="#55D6BE" type="classification"/> {/* <LearningCurve
        // file={learningCurve}/> */} <LearningCurveJSON
        // scoreName="Learning Curve" train_sizes={experiment.data.train_sizes}
        // train_scores={experiment.data.train_scores}
        // test_scores={experiment.data.test_scores} chartKey="learning_curve"
        // chartColor="#55D6BE" type="classification"/> {/* <PCA file={pca}/> */}
        // <PCAJSON                             scoreName="PCA 2D"
        // Points={experiment.data.X_pca} Labels={experiment.data.y_pca}
        // chartKey="pca_2d" chartColor="#55D6BE"
        // type="classification"/> {/* <TSNE file={tsne}/> */}
        // {/* <TSNEJSON file={tsne_json}/> */}                         {/* <TSNEJSON
        // scoreName="TSNE 2D"           Points={experiment.data.X_tsne}
        // Labels={experiment.data.y_tsne}           chartKey="tsne_2d"
        // chartColor="#55D6BE"           type="classification"         /> */ }
        // </Grid.Column>                     <Grid.Column> {/* <NoScore
        // scoreName="Class Rate" scoreValueList={class_percentage}
        // chartKey="test" chartColor="#55D6BE"           type="classification"
        // /> */ }                         <ClassRate scoreName="Class Rate"
        // scoreValueList={class_percentage}                             chartKey="test"
        // chartColor="#55D6BE"                             type="classification"/> {/*
        // <ConfusionMatrix file={confusionMatrix} /> */}                         {/*
        // This TestChart is for interactive and responsive confusion matrix */}
        // <ConfusionMatrixJSON                             scoreName="Confusion Matrix"
        // cnf_data={experiment.data.cnf_matrix} chartKey="test_chart"
        // chartColor="#55D6BE" type="classification"/>
        // <ROCCurve file={rocCurve}/> <ShapSummaryCurve
        // fileDict={shapSummaryCurveDict} shap_explainer={shap_explainer}
        // shap_num_samples={shap_num_samples}/>                         <TSNEJSON
        // scoreName="TSNE 2D" Points={experiment.data.X_tsne}
        // Labels={experiment.data.y_tsne} chartKey="tsne_2d"
        // chartColor="#55D6BE" type="classification"/>
        // </Grid.Column> <Grid.Column>                         <Score
        // scoreName="Balanced Accuracy" scoreValueList={balancedAccList}
        // chartKey="all" chartColor="#7D5BA6"
        // type="classification"/> <Score                             scoreName="AUC"
        // scoreValueList={aucList}                             chartKey="auc_scores"
        // chartColor="#55D6BE"                             type="classification"/>
        // <Score                             scoreName="Precision"
        // scoreValueList={precisionList} chartKey="precision_scores"
        // chartColor="#55D6BE" type="classification"/>                         <Score
        // scoreName="Recall"                             scoreValueList={recallList}
        // chartKey="recall_scores"                             chartColor="#55D6BE"
        // type="classification"/>                         <Score scoreName="F1 Score"
        // scoreValueList={f1List} chartKey="f1_scores"
        // chartColor="#55D6BE" type="classification"/> {/*
        // https://en.wikipedia.org/wiki/Confusion_matrix
        // */}                     </Grid.Column>                 </Grid.Row> </Grid>
        // {/* GPT Space */}             {/* <Grid columns={4} stackable="stackable">
        // <ChatGPT/>   </Grid> */             } {/* GPT Space */}             <ChatGPT
        // experiment={experiment}/> </div>
      );
    } else if (experiment.data.prediction_type == "regression") {
      // regression
      let importanceScore,
        reg_cv_pred,
        reg_cv_resi,
        reg_cv_qq,
        reg_cvp_png,
        reg_cvp_json,
        reg_cvr_png,
        reg_cvr_json,
        reg_qqnr_png,
        reg_qqnr_json;

      experiment.data.experiment_files.forEach((file) => {
        const filename = file.filename;
        console.log("filename-regression", filename);
        if (filename.includes("imp_score")) {
          importanceScore = file;
        } else if (filename.includes("reg_cv_pred")) {
          reg_cv_pred = file;
        } else if (filename.includes("reg_cv_resi")) {
          reg_cv_resi = file;
        } else if (filename.includes("reg_cv_qq")) {
          reg_cv_qq = file;
        } else if (
          filename.includes("reg_cv_pred") &&
          filename.includes("png")
        ) {
          reg_cvp_png = file;
          console.log("reg_cvp_png", reg_cvp_png);
        } else if (
          filename.includes("reg_cv_resi") &&
          filename.includes("png")
        ) {
          reg_cvr_png = file;
          console.log("reg_cvr_png", reg_cvr_png);
        } else if (filename.includes("reg_cv_qq") && filename.includes("png")) {
          reg_qqnr_png = file;
        } else if (filename.includes("reg_cvp") && filename.includes("json")) {
          reg_cvp_json = file;
          console.log("reg_cvp_json", reg_cvp_json);
        } else if (filename.includes("reg_cvr") && filename.includes("json")) {
          reg_cvr_json = file;
          console.log("reg_cvr_json", reg_cvr_json);
        } else if (filename.includes("reg_qqnr") && filename.includes("json")) {
          reg_qqnr_json = file;
          console.log("reg_qqnr_json", reg_qqnr_json);
        }
      });
      // r2
      let R2Keys = ["train_r2_score", "r2_score"];
      // r
      let RKeys = ["train_pearsonr_score", "pearsonr_score"];
      // r2
      let VAFKeys = [
        "train_explained_variance_score",
        "explained_variance_score",
      ];

      let R2List = this.getGaugeArray(R2Keys);
      let RList = this.getGaugeArray(RKeys);
      let VAFList = this.getGaugeArray(VAFKeys);

      return (
        <div className="containerChartsChats">
          <div className="chartschat chartsbaseleft">
            <Grid columns={2} stackable="stackable">
              <Grid.Row>
                <Grid.Column>
                  <SceneHeader
                    header={`Results: ${formatDataset(
                      experiment.data.dataset_name
                    )}`}
                    subheader={`Experiment: #${experiment.data._id}`}
                  />
                </Grid.Column>
                <Grid.Column>
                  <Menu
                    compact="compact"
                    inverted="inverted"
                    floated="right"
                    color="grey"
                  >
                    <Dropdown
                      text="Download"
                      simple="simple"
                      item="item"
                      disabled={["cancelled", "fail"].includes(
                        experiment.data.status
                      )}
                    >
                      <Dropdown.Menu>
                        <Dropdown.Item
                          key="model"
                          icon="download"
                          text="Model"
                          onClick={() => downloadModel(experiment.data._id)}
                        />
                        ,
                        <Dropdown.Item
                          key="script"
                          icon="download"
                          text="Script"
                          onClick={() => downloadScript(experiment.data._id)}
                        />
                      </Dropdown.Menu>
                    </Dropdown>
                  </Menu>
                </Grid.Column>
              </Grid.Row>
            </Grid>
            <Grid columns={3} stackable="stackable">
              <Grid.Row>
                <Grid.Column>
                  <AlgorithmDetails
                    algorithm={experiment.data.algorithm}
                    params={experiment.data.params}
                  />
                  <RunDetails
                    startTime={experiment.data.started}
                    finishTime={experiment.data.finished}
                    launchedBy={experiment.data.launched_by}
                  />{" "}
                  {/* <ImportanceScore file={importanceScore} /> */}
                  <ImportanceScoreJSON
                    scoreName="Feature Importance"
                    scoreValueList={experiment.data.feature_importances}
                    featureList={experiment.data.feature_names}
                    chartKey="importance_score"
                    chartColor="#55D6BE"
                    type="regression"
                    data={experiment.data}
                  />
                </Grid.Column>
                <Grid.Column>
                  {/* <RegFigure file={reg_cv_pred} /> */}
                  {/* <RegFigure file={reg_cv_resi} /> */}
                  {/* <RegFigure file={reg_cv_qq} /> */}

                  {/* {
                                        experiment.data.CVP_2d === undefined
                                            ?  <Header inverted size="tiny" content="experiment.data.CVP_2d is empty." />
                                            : <PCAJSON
                                                    scoreName="Cross-Validated Predictions"
                                                    Points={experiment.data.CVP_2d}
                                                    Labels={experiment.data.CVP_2d_class}
                                                    chartKey="CVP"
                                                    chartColor="#55D6BE"
                                                    type="classification"/>
                                    } */}
                  <GenPLOT
                    scoreName="Cross-Validated Predictions"
                    file={reg_cvp_json}
                    chartKey="CVP"
                    chartColor="#55D6BE"
                    type="classification"
                  />

                  {/* <PCAJSONV
                                        scoreName="Cross-Validated Predictions"
                                        Points={experiment.data.CVP_2d}
                                        Labels={experiment.data.CVP_2d_class}
                                        chartKey="CVP"
                                        chartColor="#55D6BE"
                                        type="classification"
                                        data={experiment.data}/> */}

                  {/* {
                                        experiment.data.CVR_2d === undefined
                                            ? <Header inverted size="tiny" content="experiment.data.CVR_2d is empty." />
                                            : <PCAJSON
                                                    scoreName="Cross-Validated Residuals"
                                                    Points={experiment.data.CVR_2d}
                                                    Labels={experiment.data.CVR_2d_class}
                                                    chartKey="CVR"
                                                    chartColor="#55D6BE"
                                                    type="classification"/>
                                    } */}
                  <GenPLOT
                    scoreName="Cross-Validated Residuals"
                    file={reg_cvr_json}
                    chartKey="CVR"
                    chartColor="#55D6BE"
                    type="classification"
                  />

                  {/* {
                                        experiment.data.QQNR_2d === undefined
                                            ? <Header inverted size="tiny" content="experiment.data.QQNR_2d is empty." />
                                            : <PCAJSON
                                                    scoreName="Q-Q Plot for Normalized Residuals"
                                                    Points={experiment.data.QQNR_2d}
                                                    Labels={experiment.data.QQNR_2d_class}
                                                    chartKey="QQNR"
                                                    chartColor="#55D6BE"
                                                    type="classification"/>
                                    } */}

                  <GenPLOT
                    scoreName="Q-Q Plot for Normalized Residuals"
                    file={reg_qqnr_json}
                    chartKey="QQNR"
                    chartColor="#55D6BE"
                    type="classification"
                  />
                </Grid.Column>
                <Grid.Column>
                  <MSEMAEDetails scores={experiment.data.scores} />
                  <Score
                    scoreName="Coefficient of Determination"
                    scoreValueList={R2List}
                    chartKey="R2"
                    chartColor="#55D6BE"
                    type="r2_or_vaf"
                  />
                  <Score
                    scoreName="Explained Variance"
                    scoreValueList={VAFList}
                    chartKey="VAF"
                    chartColor="#55D6BE"
                    type="r2_or_vaf"
                  />
                  <Score
                    scoreName="Pearson's r"
                    scoreValueList={RList}
                    chartKey="pearsonr"
                    chartColor="#55D6BE"
                    type="pearsonr"
                  />
                </Grid.Column>
              </Grid.Row>
            </Grid>
          </div>
          <div
            className="slider"
            onMouseOver={moveSlidermakeBlack}
            onMouseOut={makeOriginColor}
          >
            {/* onChange={moveSlidermakeBlack} */}
            ""<br></br>
            ""<br></br>
            ""<br></br>
            ""<br></br>
            ""<br></br>
            ""<br></br>
          </div>
          <div id="chatgpt-space" className="chartschat chatbaseright">
            <ChatGPT experiment={experiment} />
          </div>
        </div>
      );
    }
  }
}

const mapStateToProps = (state) => ({ experiment: state.experiments.selected });

export { Results };
export default connect(mapStateToProps, actions)(Results);
