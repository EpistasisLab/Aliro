/* ~This file is part of the Aliro library~

Copyright (C) 2017 Epistasis Lab, University of Pennsylvania

Aliro is maintained by:
    - Heather Williams (hwilli@upenn.edu)
    - Weixuan Fu (weixuanf@upenn.edu)
    - William La Cava (lacava@upenn.edu)
    - Michael Stauffer (stauffer@upenn.edu)
    - and many other generous open source contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

(Autogenerated header, do not modify)

*/
import React, { Component } from 'react';

// import c3 from 'c3';

import d3 from 'd3';

class ConfusionMatrixJSONRender extends Component {
  componentDidMount() {
    console.log("hello");
 
    const { cnf_data,chartKey, chartColor, min, max } = this.props;
    this.renderChart(cnf_data, chartKey, chartColor, min, max);
  }

 


  renderChart(cnf_data, chartKey, chartColor, min, max) {
    // console.log('here in renderChart for ConfusionMatrixJSONRender');
    



    

    function Matrix_ver3(options) {
	
      // var margin = {top: 100, right: 100, bottom: 100, left: 100},
      // var margin = {top: 50, right: 50, bottom: 50, left: 50},
      var margin = {top: 200, right: 200, bottom: 200, left: 200},
          width = 250,
          height = 250,
          svg = options.svg,
          data = options.data,
          // container = options.container,
          labelsData = options.labels,
          numrows,
          numcols;
    
      if(!data){
        throw new Error('No data passed.');
      }
    
      if(!Array.isArray(data) || !data.length || !Array.isArray(data[0])){
        throw new Error('Data type should be two-dimensional Array.');
      }
    
      numrows = data.length;
      numcols = data[0].length;

      // sum all the values in the matrix
      var sum = 0;
      for (var i = 0; i < numrows; i++) {
        for (var j = 0; j < numcols; j++) {
          sum += data[i][j];
        }
      }

      var max = 0;
      // find max value in the matrix
      for (var i = 0; i < numrows; i++) {
        for (var j = 0; j < numcols; j++) {
          if (data[i][j] > max) {
            max = data[i][j];
          }
        }
      }

      var min = 0;
      // find min value in the matrix
      for (var i = 0; i < numrows; i++) {
        for (var j = 0; j < numcols; j++) {
          if (data[i][j] < min) {
            min = data[i][j];
          }
        }
      }

      // console.log("sum",sum);

    
      // var svg = d3.select(container).append("svg")
      svg
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        // .attr("transform", "translate(" + 500 + "," + 500 + ")");
    
      var background = svg.append("rect")
          .style("stroke", "black")
          .style("stroke-width", "2px")
          .attr("width", width)
          .attr("height", height);
    
    
      var x = d3.scale.ordinal()
          .domain(d3.range(numcols))
          .rangeBands([0, width]);
    
      var y = d3.scale.ordinal()
          .domain(d3.range(numrows))
          .rangeBands([0, height]);
    
      var colorMap = d3.scale.linear()
          // .domain([0, sum])
          // .domain([0, max])
          .domain([min, max])
          // make 
          // .range(["red", "blue"]); 
          // .range(["white", "red", "green"]);   
          // .range(["white", "blue"]);
          // use dark red and  dark blue
          .range(["#afacbd", "#092180"]);
          // .range(["white", "#55D6BE"]);
          
          // [#afacbd, 7D5BA6] 
          
          // .range()

    
      var row = svg.selectAll(".row")
          .data(data)
          .enter().append("g")
          .attr("class", "row")
          .attr("transform", function(d, i) { return "translate(0," + y(i) + ")"; });
    
      var cell = row.selectAll(".cell")
          .data(function(d) { return d; })
          .enter().append("g")
          .attr("class", "cell")
          .attr("transform", function(d, i) { return "translate(" + x(i) + ", 0)"; });
    
      cell.append('rect')    
          .attr("width", x.rangeBand())
          .attr("height", y.rangeBand())
          .style("stroke-width", 0.5)
          .style("stroke", "white")
          // when user mouseover, change the stroke-width to 1
          .on("mouseover", function(d) {


            // apply opacity to the background color
            d3.select(this).style("opacity", 0.5);

            


          })
          // when user mouseout, change the stroke-width to 0.5
          .on("mouseout", function(d) {


            // apply opacity to the background color
            d3.select(this).style("opacity", 1);

          })


      
    
      cell.append("text")
        .attr("dy", ".32em")
        .attr("x", x.rangeBand() / 2)
        .attr("y", y.rangeBand() / 2)
        .attr("text-anchor", "middle")
        .style("fill", function(d, i) { return d >= 0.5 ? 'white' : 'black'; })
        .text(function(d, i) { return d; });
    
      row.selectAll(".cell")
          .data(function(d, i) { return (data[i]) ; })
          .style("fill", colorMap);
    
      var labels = svg.append('g')
        .attr('class', "labels");
    
      var columnLabels = labels.selectAll(".column-label")
          .data(labelsData)
        .enter().append("g")
          .attr("class", "column-label")
          .attr("transform", function(d, i) { return "translate(" + x(i) + "," + height + ")"; });
    
      columnLabels.append("line")
        .style("stroke", "black")
          .style("stroke-width", "1px")
          .attr("x1", x.rangeBand() / 2)
          .attr("x2", x.rangeBand() / 2)
          .attr("y1", 0)
          .attr("y2", 5);
    
      columnLabels.append("text")
          .attr("x", 6)
          .attr("y", y.rangeBand() / 2)
          .attr("dy", ".32em")
          .attr("text-anchor", "end")
          .attr("transform", "rotate(-60)")
          .text(function(d, i) { return d; });


      svg.append("text")
        .attr("x", 170)
        // .attr("y", y.rangeBand() / 1.5)
        .attr("y", 330)
        // .attr("dy", ".32em")
        .attr("text-anchor", "end")
        // .attr("transform", "rotate(-60)")
        .text("Predicted label")
        // mouseover, change the text size to 20
        .on("mouseover", function(d) {
          // d3.select(this).style("font-size", 20);

          // bold
          d3.select(this).style("font-weight", "bold");
        })
        // mouseout, change the text size to 10
        .on("mouseout", function(d) {
          // d3.select(this).style("font-size", 10);

          // remove bold
          d3.select(this).style("font-weight", "normal");
        })
        ;
        
    
      var rowLabels = labels.selectAll(".row-label")
          .data(labelsData)
          .enter().append("g")
          .attr("class", "row-label")
          .attr("transform", function(d, i) { return "translate(" + 0 + "," + y(i) + ")"; });
    
      rowLabels.append("line")
        .style("stroke", "black")
          .style("stroke-width", "1px")
          .attr("x1", 0)
          .attr("x2", -5)
          .attr("y1", y.rangeBand() / 2)
          .attr("y2", y.rangeBand() / 2);
    
      rowLabels.append("text")
          .attr("x", -8)
          .attr("y", y.rangeBand() / 2)
          .attr("dy", ".32em")
          .attr("text-anchor", "end")
          .text(function(d, i) { return d; });

      
      svg.append("text")
          .attr("x", -85)
          // .attr("y", y.rangeBand() / 1.5)
          .attr("y", -60)
          // .attr("dy", ".32em")
          .attr("text-anchor", "end")
          .attr("transform", "rotate(-90)")
          .text("True label")
          .attr("id", "true_label")
          // mouseover, change the text size to 20
          .on("mouseover", function(d) {
            // d3.select(this).style("font-size", 20);

            // make it bold
            d3.select(this).style("font-weight", "bold");
          })
          // mouseout, change the text size to 10
          .on("mouseout", function(d) {
            // d3.select(this).style("font-size", 10);
            // remove bold
            d3.select(this).style("font-weight", "normal");
          })
          ;
      
          

      
    
    }

    var matrix = cnf_data;  
    

    var div = d3.select(`.${chartKey}`)
    // add svg to div 
    
    var svg = div.append("svg")
    // make viewbox to make svg responsive
    .attr("viewBox", "0 0 600 400")
    .attr("preserveAspectRatio", "xMinYMin meet")
    .append("g")
    // transform to center svg
    .attr("transform", "translate(180,50)");
    
    // var matrix = [[10,20],[30,40]];


    // var matrix = [[10,20],[30,40]];



    var tempcount=0;
    
    

    

    // get length of matrix
    var matrixLength = matrix.length;
    console.log('matrixLength: ', matrixLength);

    // make the classes based on the length of matrix
    var classes = [];
    for (var i = 0; i < matrixLength; i++) {
      classes.push("Class_"+i);
    }
    console.log('classes: ', classes);
    // var labels = ['Class A', 'Class B'];
    var labels = classes;
		
    Matrix_ver3({
      svg : svg,
      
      chartKey : chartKey,
      data      : matrix,
      labels    : labels,
            start_color : '#ffffff',
            end_color : '#e67e22'
    });


  }

  render() {
    return (
      <div className={`ConfusionMatrixJSONRender ${this.props.chartKey}`} />
    );
  }
}

ConfusionMatrixJSONRender.defaultProps = {
  chartColor: '#60B044'
};

export default ConfusionMatrixJSONRender;







