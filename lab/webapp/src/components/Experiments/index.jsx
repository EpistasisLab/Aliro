/* ~This file is part of the Aliro library~

Copyright (C) 2023 Epistasis Lab,
Center for Artificial Intelligence Research and Education (CAIRE),
Department of Computational Biomedicine (CBM),
Cedars-Sinai Medical Center.

Aliro is maintained by:
    - Hyunjun Choi (hyunjun.choi@cshs.org)
    - Miguel Hernandez (miguel.e.hernandez@cshs.org)
    - Nick Matsumoto (nicholas.matsumoto@cshs.org)
    - Jay Moran (jay.moran@cshs.org)
    - and many other generous open source contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

(Autogenerated header, do not modify)

*/
import React, {Component} from 'react';
import {connect} from 'react-redux';
import {withRouter} from 'react-router';
import {getVisibleExperiments, getFilters, getSortAll} from 'data/experiments';
import * as actions from 'data/experiments/actions';
import SceneHeader from '../SceneHeader';
import FetchError from '../FetchError';
import ExperimentFilters from './components/ExperimentFilters';
import ExperimentsTable from './components/ExperimentsTable';
import {Segment, Header, Loader} from 'semantic-ui-react';
import {hashHistory} from 'react-router';
import {formatAlgorithm} from 'utils/formatter';

class Experiments extends Component {
    constructor(props) {
        super(props);
        this.updateQuery = this
            .updateQuery
            .bind(this);
        this.resetQuery = this
            .resetQuery
            .bind(this);
        this.getTables = this
            .getTables
            .bind(this);
    }

    componentDidMount() {
        this
            .props
            .fetchExperiments();
    }

    /**
   * URL/path query is used to pass props to this Experiments component, as best I understand.
   */
    updateQuery(key, value) {
        const {location} = this.props;
        const nextLocation = Object.assign({}, location);
        if (value === 'all') {
            delete nextLocation.query[key];
        } else {
            Object.assign(nextLocation.query, {[key]: value});
        }
        hashHistory.push(nextLocation);
        // Special check for Dataset value. If it's not set to show all, the Prediction
        // Type filter gets hidden in ExperimentFilters, so we have to force it's value
        // to be 'all' so it doesn't get stuck on an inappropriate value
        if (key === 'dataset' && value !== 'all') {
            this.updateQuery('prediction', 'all');
        }
        // Special check for settings viewMode. If we set 'expanded' mode, make sure the
        // algorithm filter is set to all
        if (key === 'viewMode' && value === 'expanded') {
            this.updateQuery('algorithm', 'all');
        }
    }

    resetQuery() {
        const {location} = this.props;
        const nextLocation = Object.assign({}, location);
        Object
            .keys(nextLocation.query)
            .forEach((key) => {
                delete nextLocation.query[key];
            });
        hashHistory.push(nextLocation);
    }

    /** Generate either a single table showing a single or all algorithms, or an array of tables with one for each algorithm type
   * that has one or more experiments.
   */
    getTables() {
        const {experiments, fetchExperiments, filters, sortAll} = this.props;

        if (experiments.list.length == 0) {
            return (<Header inverted="inverted" size="small" content="No results available."/>)
        }

        // We expect to iterate below over the values in an object each of is an array
        // of experiments. There's either a single value for viewMode 'simple', or one
        // or more values for viewMode 'expanded' in which each array holds experiments
        // of a single algorithm type. Note that these have been filtered by view
        // filters.
        let groupedExperiments = {};
        if (filters.viewMode === "simple") {
            groupedExperiments = {
                simple: experiments.list
            }
        } else {
            //
            groupedExperiments = experiments.byAlgorithm;
        }

        let result = [];
        Object
            .keys(groupedExperiments)
            .forEach(key => {
                let experiments = groupedExperiments[key];
                if (experiments.length > 0) {
                    result.push((
                        <Segment inverted="inverted" attached="bottom" key={experiments[0]._id}>
                            <React.Fragment>
                                {
                                    filters.viewMode === "simple"
                                        ? undefined
                                        : <Header as='h3'>{formatAlgorithm(experiments[0].algorithm)}</Header>
                                }
                                <ExperimentsTable
                                    experiments={experiments}
                                    filters={filters}
                                    sortSingle={sortAll[key]}
                                    updateQuery={this.updateQuery}/>
                            </React.Fragment>
                        </Segment>
                    ))
                }
            })
        return result;
    }

    render() {
        const {experiments, fetchExperiments, filters} = this.props;

        if (experiments.isFetching) {
            return (
                <Loader
                    active="active"
                    inverted="inverted"
                    size="large"
                    content="Retrieving your experiments..."/>
            );
        }

        if (experiments.error) {
            return (
                <FetchError message={experiments.error} onRetry={() => fetchExperiments()}/>
            );
        }

        return (
          <>
            <div className="experiments-scene">
                <SceneHeader header="Experiments"/>
                <Segment inverted="inverted" attached="top">
                    <ExperimentFilters
                        filters={filters}
                        displayCount={experiments.list.length}
                        updateQuery={this.updateQuery}
                        resetQuery={this.resetQuery}/>
                </Segment>
                {this.getTables()}

               
            </div>

             {/* GPT Space Candidate*/}
             <div
                    style={{
                        overflowY: 'auto',
                        maxHeight: '350px',
                         // red color
                        // backgroundColor: '#ff0000'
                        // black
                        backgroundColor: '#1B1C1D'

                    }}
                   
                    className='table-sticky-header file-upload-table'>
                    <p>GPT</p>
                </div>

            </>
            
        );
    }
}

const mapStateToProps = (state, props) => ({
    experiments: getVisibleExperiments(state, props),
    filters: getFilters(state, props),
    sortAll: getSortAll(state, props)
});

export {
    Experiments
};
export default withRouter(connect(mapStateToProps, actions)(Experiments));