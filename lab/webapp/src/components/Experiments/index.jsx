/* ~This file is part of the PennAI library~

Copyright (C) 2017 Epistasis Lab, University of Pennsylvania

PennAI is maintained by:
    - Heather Williams (hwilli@upenn.edu)
    - Weixuan Fu (weixuanf@upenn.edu)
    - William La Cava (lacava@upenn.edu)
    - Michael Stauffer (stauffer@upenn.edu)
    - and many other generous open source contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

(Autogenerated header, do not modify)

*/
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { withRouter } from 'react-router';
import { 
  getVisibleExperiments, 
  getFilters,
  getSort
} from 'data/experiments';
import * as actions from 'data/experiments/actions';
import SceneHeader from '../SceneHeader';
import FetchError from '../FetchError';
import ExperimentFilters from './components/ExperimentFilters';
import ExperimentsTable from './components/ExperimentsTable';
import { Segment, Header, Loader } from 'semantic-ui-react';
import { hashHistory } from 'react-router';
import { formatAlgorithm } from 'utils/formatter';

class Experiments extends Component {
  constructor(props) {
    super(props);
    this.updateQuery = this.updateQuery.bind(this);
    this.resetQuery = this.resetQuery.bind(this);
    this.getTables = this.getTables.bind(this);
    this.getExperimentsByAlgorithm = this.getExperimentsByAlgorithm.bind(this);
  }

  componentDidMount() {
    this.props.fetchExperiments();
  }

  /**
   * URL/path query is used to pass props to this Experiments component, as best I understand.
   */
  updateQuery(key, value) {
    const { location } = this.props;
    const nextLocation = Object.assign({}, location);
    if(value === 'all') {
      delete nextLocation.query[key];
    } else {
      Object.assign(nextLocation.query, { [key]: value });
    }
    hashHistory.push(nextLocation);
    //Special check for Dataset value. If it's not set to show all,
    // the Prediction Type filter gets hidden in ExperimentFilters,
    // so we have to force it's value to be 'all' so it doesn't get
    // stuck on an inappropriate value
    if(key === 'dataset' && value !== 'all'){
      this.updateQuery('prediction','all');
    }
    //Special check for settings viewMode. If we set 'expanded' mode,
    // make sure the algorithm filter is set to all
    if(key === 'viewMode' && value === 'expanded'){
      this.updateQuery('algorithm','all');
    }
  }

  resetQuery() {
    const { location } = this.props;
    const nextLocation = Object.assign({}, location);
    Object.keys(nextLocation.query).forEach((key) => {
      delete nextLocation.query[key];
    });
    hashHistory.push(nextLocation);
  }

  /** 
   * Parse the passed array of experiments and group by algorithm type.
   * Returns an object, with each key named for an algorithm and
   * holding an array of experiments that use that algorithm.
  */
  getExperimentsByAlgorithm(experimentsArray) {
    let result = {}
    experimentsArray.forEach( exp => {
      if( !result.hasOwnProperty(exp.algorithm)) {
        result[exp.algorithm] = []
      }
      result[exp.algorithm].push(exp);
    })
    return result;
  }
  
  /** Generate a single table showing single or all algorithms, or an array of table components, one for each algorithm type
   * that has one or more experiments.
   */
  getTables() {
    const { experiments, fetchExperiments, filters, sort } = this.props;

    if (experiments.list.length == 0 ) {
      return (
        <Header inverted size="small" content="No results available." />
      )
    }

    // We expect to iterate below over the values in an object each of 
    // is an array of experiments.
    // There's either a single value for viewMode 'simple', or one or more
    // values for viewMode 'expanded' in which each array holds experiments
    // of a single algorithm type.
    let groupedExperiments = {};
    if(filters.viewMode === "simple" ){
      groupedExperiments = {simple: experiments.list}
    }
    else {
      groupedExperiments = this.getExperimentsByAlgorithm(experiments.list);
    }

    let result = [];
    Object.values(groupedExperiments).forEach( experiments => {
      result.push((
        <Segment inverted attached="bottom" key={experiments[0]._id}>
          <React.Fragment>
            {filters.viewMode === "simple" ? undefined : <Header as='h3'>{formatAlgorithm(experiments[0].algorithm)}</Header>}
            <ExperimentsTable 
              experiments={experiments}
              filters={filters}
              sort={sort}
              updateQuery={this.updateQuery}
            />
          </React.Fragment>
        </Segment>
      ))
    })
    return result;
  }

  render() {
    const { experiments, fetchExperiments, filters, sort } = this.props;
    
    if(experiments.isFetching) {
      return (
        <Loader active inverted size="large" content="Retrieving your experiments..." />
      );
    }

    if(experiments.error) {
      return (
        <FetchError 
          message={experiments.error}
          onRetry={() => fetchExperiments()}
        />
      );
    }

    return (
      <div className="experiments-scene">
        <SceneHeader header="Experiments" />
          <Segment inverted attached="top">
            <ExperimentFilters
              filters={filters}
              displayCount={experiments.list.length}
              updateQuery={this.updateQuery}
              resetQuery={this.resetQuery}
            />
          </Segment>
          {this.getTables()}
      </div>
    );
  }
}

const mapStateToProps = (state, props) => ({
  experiments: getVisibleExperiments(state, props),
  filters: getFilters(state, props),
  sort: getSort(state, props)
});

export { Experiments };
export default withRouter(connect(mapStateToProps, actions)(Experiments));